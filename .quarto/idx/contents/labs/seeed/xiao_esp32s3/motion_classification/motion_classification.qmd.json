{"title":"Motion Classification and Anomaly Detection","markdown":{"headingText":"Motion Classification and Anomaly Detection","headingAttr":{"id":"","classes":["unnumbered"],"keyvalue":[]},"containsRefs":false,"markdown":"\n![*DALL·E prompt - 1950s style cartoon illustration set in a vintage audio lab. Scientists, dressed in classic attire with white lab coats, are intently analyzing audio data on large chalkboards. The boards display intricate FFT (Fast Fourier Transform) graphs and time-domain curves. Antique audio equipment is scattered around, but the data representations are clear and detailed, indicating their focus on audio analysis.*](./images/jpeg/ini.jpg)\n\n## Overview\n\nThe XIAO ESP32S3 Sense, with its built-in camera and mic, is a versatile device. But what if you need to add another type of sensor, such as an IMU? No problem! One of the standout features of the XIAO ESP32S3 is its multiple pins that can be used as an I2C bus (SDA/SCL pins), making it a suitable platform for sensor integration.\n\n![](https://hackster.imgix.net/uploads/attachments/1590599/image_GstFLMyDUy.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\n## Installing the IMU\n\nWhen selecting your IMU, the market offers a wide range of devices, each with unique features and capabilities. You could choose, for example, the ADXL362 (3-axis), MAX21100 (6-axis), MPU6050 (6-axis), LIS3DHTR (3-axis), or the LCM20600Seeed Grove— (6-axis), which is part of the IMU 9DOF (lcm20600+AK09918). This variety allows you to tailor your choice to your project's specific needs.\n\nFor this project, we will use an IMU, the MPU6050 (or 6500), a low-cost (less than 2.00 USD) 6-axis Accelerometer/Gyroscope unit.\n\n> At the end of the lab, we will also comment on using the LCM20600.\n\nThe [MPU-6500](https://invensense.tdk.com/download-pdf/mpu-6500-datasheet/) is a 6-axis Motion Tracking device that combines a 3-axis gyroscope, 3-axis accelerometer, and a Digital Motion ProcessorTM (DMP) in a small 3x3x0.9mm package. It also features a 4096-byte FIFO that can lower the traffic on the serial bus interface and reduce power consumption by allowing the system processor to burst read sensor data and then go into a low-power mode.\n\nWith its dedicated I2C sensor bus, the MPU-6500 directly accepts inputs from external I2C devices. MPU-6500, with its 6-axis integration, on-chip DMP, and run-time calibration firmware, enables manufacturers to eliminate the costly and complex selection, qualification, and system-level integration of discrete devices, guaranteeing optimal motion performance for consumers. MPU-6500 is also designed to interface with multiple non-inertial digital sensors, such as pressure sensors, on its auxiliary I2C port.\n\n![](https://hackster.imgix.net/uploads/attachments/1590608/image_ZFuJgZIdRi.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\n> Usually, the libraries available are for MPU6050, but they work for both devices.\n\n**Connecting the HW**\n\nConnect the IMU to the XIAO according to the below diagram:\n\n- MPU6050 **SCL** --> XIAO **D5**\n- MPU6050 **SDA** --> XIAO **D4**\n- MPU6050 **VCC** --> XIAO **3.3V**\n- MPU6050 **GND** --> XIAO **GND**\n\n![](https://hackster.imgix.net/uploads/attachments/1590645/drawing_Vp4G8xChAB.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\n**Install the Library**\n\nGo to Arduino Library Manager and type MPU6050. Install the latest version.\n\n![](https://hackster.imgix.net/uploads/attachments/1590642/pasted_graphic_16_CH1rHB6s2M.png?auto=compress%2Cformat&w=1280&h=960&fit=max)\n\nDownload the sketch [MPU6050_Acc_Data_Acquisition.in](https://github.com/Mjrovai/XIAO-ESP32S3-Sense/tree/main/IMU/MPU6050_Acc_Data_Acquisition):\n\n```\n/*\n * Based on I2C device class (I2Cdev) Arduino sketch for MPU6050 class \n   by Jeff Rowberg <jeff@rowberg.net>\n * and Edge Impulse Data Forwarder Exampe (Arduino) \n   - https://docs.edgeimpulse.com/docs/cli-data-forwarder\n * \n * Developed by M.Rovai @11May23\n */\n\n#include \"I2Cdev.h\"\n#include \"MPU6050.h\"\n#include \"Wire.h\"\n\n#define FREQUENCY_HZ        50\n#define INTERVAL_MS         (1000 / (FREQUENCY_HZ + 1))\n#define ACC_RANGE           1 // 0: -/+2G; 1: +/-4G\n\n// convert factor g to m/s^2^ ==> [-32768, +32767] ==> [-2g, +2g]\n#define CONVERT_G_TO_MS2    (9.81/(16384.0/(1.+ACC_RANGE))) \n\nstatic unsigned long last_interval_ms = 0;\n\nMPU6050 imu;\nint16_t ax, ay, az;\n\nvoid setup() {\n  \n    Serial.begin(115200);\n\n    \n    // initialize device\n    Serial.println(\"Initializing I2C devices...\");\n    Wire.begin();\n    imu.initialize();\n    delay(10);\n    \n//    // verify connection\n//    if (imu.testConnection()) {\n//      Serial.println(\"IMU connected\");\n//    }\n//    else {\n//      Serial.println(\"IMU Error\");\n//    }\n    delay(300);\n    \n    //Set MCU 6050 OffSet Calibration \n    imu.setXAccelOffset(-4732);\n    imu.setYAccelOffset(4703);\n    imu.setZAccelOffset(8867);\n    imu.setXGyroOffset(61);\n    imu.setYGyroOffset(-73);\n    imu.setZGyroOffset(35);\n    \n    /* Set full-scale accelerometer range.\n     * 0 = +/- 2g\n     * 1 = +/- 4g\n     * 2 = +/- 8g\n     * 3 = +/- 16g\n     */\n    imu.setFullScaleAccelRange(ACC_RANGE);\n}\n\nvoid loop() {\n\n      if (millis() > last_interval_ms + INTERVAL_MS) {\n        last_interval_ms = millis();\n        \n        // read raw accel/gyro measurements from device\n        imu.getAcceleration(&ax, &ay, &az);\n\n        // converting to m/s^2^\n        float ax_m_s^2^ = ax * CONVERT_G_TO_MS2;\n        float ay_m_s^2^ = ay * CONVERT_G_TO_MS2;\n        float az_m_s^2^ = az * CONVERT_G_TO_MS2;\n\n        Serial.print(ax_m_s^2^); \n        Serial.print(\"\\t\");\n        Serial.print(ay_m_s^2^); \n        Serial.print(\"\\t\");\n        Serial.println(az_m_s^2^); \n      }\n}\n```\n\n**Some comments about the code:**\n\nNote that the values generated by the accelerometer and gyroscope have a range: [-32768, +32767], so for example, if the default accelerometer range is used, the range in Gs should be: [-2g, +2g]. So, \"1G\" means 16384.\n\nFor conversion to m/s^2^, for example, you can define the following:\n\n```\n#define CONVERT_G_TO_MS2 (9.81/16384.0)\n```\n\nIn the code, I left an option (ACC_RANGE) to be set to 0 (+/-2G) or 1 (+/- 4G). We will use +/-4G; that should be enough for us. In this case.\n\nWe will capture the accelerometer data on a frequency of 50Hz, and the acceleration data will be sent to the Serial Port as meters per squared second (m/s^2^).\n\nWhen you ran the code with the IMU resting over your table, the accelerometer data shown on the Serial Monitor should be around 0.00, 0.00, and 9.81. If the values are a lot different, you should calibrate the IMU.\n\nThe MCU6050 can be calibrated using the sketch: [mcu6050-calibration.ino](https://github.com/Mjrovai/XIAO-ESP32S3-Sense/tree/main/IMU/mcu6050-calibration).\n\nRun the code. The following will be displayed on the Serial Monitor:\n\n![](https://hackster.imgix.net/uploads/attachments/1590654/pasted_graphic_19_FhU4qX0dLU.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\nSend any character (in the above example, \"x\"), and the calibration should start.\n\n> Note that a message MPU6050 connection failed. Ignore this message. For some reason, imu.testConnection() is not returning a correct result.\n\nIn the end, you will receive the offset values to be used on all your sketches:\n\n![](https://hackster.imgix.net/uploads/attachments/1590656/pasted_graphic_20_Tui5mRNqOL.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\nTake the values and use them on the setup:\n\n```\n//Set MCU 6050 OffSet Calibration \nimu.setXAccelOffset(-4732);\nimu.setYAccelOffset(4703);\nimu.setZAccelOffset(8867);\nimu.setXGyroOffset(61);\nimu.setYGyroOffset(-73);\nimu.setZGyroOffset(35);\n```\n\nNow,  run the sketch [MPU6050_Acc_Data_Acquisition.in:](https://github.com/Mjrovai/XIAO-ESP32S3-Sense/tree/main/IMU/MPU6050_Acc_Data_Acquisition)\n\nOnce you run the above sketch, open the Serial Monitor:\n\n![](https://hackster.imgix.net/uploads/attachments/1590659/pasted_graphic_21_DTRap3UbE7.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\nOr check the Plotter:\n\n![](https://hackster.imgix.net/uploads/attachments/1590660/pasted_graphic_23_hM0BpXdmeI.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\nMove your device in the three axes. You should see the variation on Plotter:\n\n![](https://hackster.imgix.net/uploads/attachments/1590661/pasted_graphic_22_qOS34YmKic.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\n## The TinyML Motion Classification Project\n\nFor our lab, we will simulate mechanical stresses in transport. Our problem will be to classify four classes of movement:\n\n- **Maritime** (pallets in boats)\n- **Terrestrial** (palettes in a Truck or Train)\n- **Lift** (Palettes being handled by Fork-Lift)\n- **Idle** (Palettes in Storage houses)\n\nSo, to start, we should collect data. Then, accelerometers will provide the data on the palette (or container).\n\n![](https://hackster.imgix.net/uploads/attachments/1590536/data1_sg5MS6KfkM.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\nFrom the above images, we can see that primarily horizontal movements should be associated with the \"Terrestrial class, \" Vertical movements with the \"Lift Class, \" no activity with the \"Idle class, \" and movement on all three axes to [Maritime class.](https://www.containerhandbuch.de/chb_e/stra/index.html?/chb_e/stra/stra_02_03_03.htm)\n\n## Connecting the device to Edge Impulse\n\nFor data collection, we should first connect our device to the Edge Impulse Studio, which will also be used for data pre-processing, model training, testing, and deployment.\n\n> Follow the instructions [here](https://docs.edgeimpulse.com/docs/edge-impulse-cli/cli-installation)to install the [Node.js](https://nodejs.org/en/)and Edge Impulse CLI on your computer.\n\nOnce the XIAO ESP32S3 is not a fully supported development board by Edge Impulse, we should, for example, use the [CLI Data Forwarder](https://docs.edgeimpulse.com/docs/edge-impulse-cli/cli-data-forwarder) to capture data from our sensor and send it to the Studio, as shown in this diagram:\n\n![](https://hackster.imgix.net/uploads/attachments/1590537/image_PHK0GELEYh.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\n> You can alternately capture your data \"offline,\" store them on an SD card or send them to your computer via Bluetooth or Wi-Fi. In this [video](https://youtu.be/2KBPq_826WM), you can learn alternative ways to send data to the Edge Impulse Studio.\n\nConnect your device to the serial port and run the previous code to capture IMU (Accelerometer) data, \"printing them\" on the serial. This will allow the Edge Impulse Studio to \"capture\" them.\n\nGo to the Edge Impulse page and create a project.\n\n![](https://hackster.imgix.net/uploads/attachments/1590663/image_xUyC0uWhnG.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\n> The maximum length for an Arduino library name is **63 characters**. Note that the Studio will name the final library using your project name and include “_inference” to it. The name I chose initially did not work when I tried to deploy the Arduino library because it resulted in 64 characters. So, I need to change it by taking out the “anomaly detection” part.\n\nStart the [CLI Data Forwarder](https://docs.edgeimpulse.com/docs/edge-impulse-cli/cli-data-forwarder)on your terminal, entering (if it is the first time) the following command:\n\n```\nedge-impulse-data-forwarder --clean\n```\n\nNext, enter your EI credentials and choose your project, variables, and device names:\n\n![](https://hackster.imgix.net/uploads/attachments/1590664/image_qkRsm7A981.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\nGo to your EI Project and verify if the device is connected (the dot should be green):\n\n![](https://hackster.imgix.net/uploads/attachments/1590667/image_a5J303wHbE.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\n## Data Collection\n\nAs discussed before, we should capture data from all four Transportation Classes. Imagine that you have a container with a built-in accelerometer:\n\n![](https://hackster.imgix.net/uploads/attachments/1591091/boat_aOqDzqArqs.jpg?auto=compress%2Cformat&w=740&h=555&fit=max)\n\nNow imagine your container is on a boat, facing an angry ocean, on a truck, etc.:\n\n- **Maritime** (pallets in boats)\n  - Move the XIAO in all directions, simulating an undulatory boat movement.\n\n- **Terrestrial** (palettes in a Truck or Train)\n  - Move the XIAO over a horizontal line.\n\n- **Lift** (Palettes being handled by Fork-Lift)\n  - Move the XIAO over a vertical line.\n\n- **Idle** (Palettes in Storage houses)\n  - Leave the XIAO over the table.\n\n![](https://hackster.imgix.net/uploads/attachments/1590677/idle_OiZWwciVVh.jpg?auto=compress%2Cformat&w=740&h=555&fit=max)\n\nBelow is one sample (raw data) of 10 seconds:\n\n![](https://hackster.imgix.net/uploads/attachments/1590541/image_E3mFL7tvSh.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\nYou can capture, for example, 2 minutes  (twelve samples of 10 seconds each) for the four classes. Using the \"3 dots\" after each one of the samples, select 2, moving them for the Test set (or use the automatic Train/Test Split tool on the Danger Zone of Dashboard tab). Below, you can see the result datasets:\n\n![](https://hackster.imgix.net/uploads/attachments/1590679/image_WB3eKzzN6R.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\n## Data Pre-Processing\n\nThe raw data type captured by the accelerometer is a \"time series\" and should be converted to \"tabular data\". We can do this conversion using a sliding window over the sample data. For example, in the below figure,\n\n![](https://hackster.imgix.net/uploads/attachments/1590693/image_KQNIPcxqXV.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\nWe can see 10 seconds of accelerometer data captured with a sample rate (SR) of 50Hz. A 2-second window will capture 300 data points (3 axis x 2 seconds x 50 samples). We will slide this window each 200ms, creating a larger dataset where each instance has 300 raw features.\n\n> You should use the best SR for your case, considering Nyquist's theorem, which states that a periodic signal must be sampled at more than twice the signal's highest frequency component.\n\nData preprocessing is a challenging area for embedded machine learning. Still, Edge Impulse helps overcome this with its digital signal processing (DSP) preprocessing step and, more specifically, the Spectral Features.\n\nOn the Studio, this dataset will be the input of a Spectral Analysis block, which is excellent for analyzing repetitive motion, such as data from accelerometers. This block will perform a DSP (Digital Signal Processing), extracting features such as \"FFT\" or \"Wavelets\". In the most common case, FFT, the **Time Domain Statistical features** per axis/channel are:\n\n- RMS\n- Skewness\n- Kurtosis\n\nAnd the **Frequency Domain Spectral features** per axis/channel are:\n\n- Spectral Power\n- Skewness\n- Kurtosis\n\nFor example, for an FFT length of 32 points, the Spectral Analysis Block's resulting output will be 21 features per axis (a total of 63 features).\n\nThose 63 features will be the Input Tensor of a Neural Network Classifier and the Anomaly Detection model (K-Means).\n\n> You can learn more by digging into the lab [DSP Spectral Features](../../../shared/dsp_spectral_features_block/dsp_spectral_features_block.qmd)\n\n## Model Design\n\nOur classifier will be a Dense Neural Network (DNN) that will have 63 neurons on its input layer, two hidden layers with 20 and 10 neurons, and an output layer with four neurons (one per each class), as shown here:\n\n![](https://hackster.imgix.net/uploads/attachments/1590702/image_ojSbkXrKse.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\n## Impulse Design\n\nAn impulse takes raw data, uses signal processing to extract features, and then uses a learning block to classify new data.\n\nWe also take advantage of a second model, the K-means, that can be used for Anomaly Detection. If we imagine that we could have our known classes as clusters, any sample that could not fit on that could be an outlier, an anomaly (for example, a container rolling out of a ship on the ocean).\n\n![](https://hackster.imgix.net/uploads/attachments/1590547/image_pFnNVK4Wjc.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\n> Imagine our XIAO rolling or moving upside-down, on a movement complement different from the one trained\n\n![](https://hackster.imgix.net/uploads/attachments/1590548/image_iW1ygppsHi.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\nBelow is our final Impulse design:\n\n![](https://hackster.imgix.net/uploads/attachments/1590696/image_W8xMffuTwP.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\n## Generating features\n\nAt this point in our project, we have defined the pre-processing method and the model designed. Now, it is time to have the job done. First, let's take the raw data (time-series type) and convert it to tabular data. Go to the Spectral Features tab and select Save Parameters:\n\n![](https://hackster.imgix.net/uploads/attachments/1590697/image_bsHjHtleGs.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\nAt the top menu, select the Generate Features option and the Generate Features button. Each 2-second window data will be converted into one data point of 63 features.\n\n> The Feature Explorer will show those data in 2D using [UMAP.](https://umap-learn.readthedocs.io/en/latest/) Uniform Manifold Approximation and Projection (UMAP) is a dimension reduction technique that can be used for visualization similarly to t-SNE but also for general non-linear dimension reduction.\n\nThe visualization allows one to verify that the classes present an excellent separation, which indicates that the classifier should work well.\n\n![](https://hackster.imgix.net/uploads/attachments/1590706/image_fyynJu1laN.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\nOptionally, you can analyze the relative importance of each feature for one class compared with other classes.\n\n## Training\n\nOur model has four layers, as shown below:\n\n![](https://hackster.imgix.net/uploads/attachments/1590707/image_0M4u1e4dJI.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\nAs hyperparameters, we will use a Learning Rate of 0.005 and 20% of data for validation for 30 epochs. After training, we can see that the accuracy is 97%.\n\n![](https://hackster.imgix.net/uploads/attachments/1590709/image_cCscB5HMw9.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\nFor anomaly detection, we should choose the suggested features that are precisely the most important in feature extraction. The number of clusters will be 32, as suggested by the Studio:\n\n![](https://hackster.imgix.net/uploads/attachments/1590710/image_8IOqOw1yoX.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\n## Testing\n\nUsing 20% of the data left behind during the data capture phase, we can verify how our model will behave with unknown data; if not 100% (what is expected), the result was not that good (8%), mainly due to the terrestrial class. Once we have four classes (which output should add 1.0), we can set up a lower threshold for a class to be considered valid (for example, 0.4):\n\n![](https://hackster.imgix.net/uploads/attachments/1590714/image_ecSV5fIlPu.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\nNow, the Test accuracy will go up to 97%.\n\n![](https://hackster.imgix.net/uploads/attachments/1590715/image_TnLYYt60Vc.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\nYou should also use your device (which is still connected to the Studio) and perform some Live Classification.\n\n> Be aware that here you will capture real data with your device and upload it to the Studio, where an inference will be taken using the trained model (But the model is NOT in your device).\n\n## Deploy\n\nNow it is time for magic! The Studio will package all the needed libraries, preprocessing functions, and trained models, downloading them to your computer. You should select the option Arduino Library, and at the bottom, choose Quantized (Int8) and Build. A Zip file will be created and downloaded to your computer.\n\n![](https://hackster.imgix.net/uploads/attachments/1590716/image_d5jrYgBErG.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\nOn your Arduino IDE, go to the Sketch tab, select the option Add.ZIP Library, and Choose the.zip file downloaded by the Studio:\n\n![](https://hackster.imgix.net/uploads/attachments/1590717/image_6w7t1NYsBV.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\n## Inference\n\nNow, it is time for a real test. We will make inferences that are wholly disconnected from the Studio. Let's change one of the code examples created when you deploy the Arduino Library.\n\nIn your Arduino IDE, go to the File/Examples tab and look for your project, and on examples, select nano_ble_sense_accelerometer:\n\n![](https://hackster.imgix.net/uploads/attachments/1590718/image_M3k3wqDRto.png?auto=compress%2Cformat&w=740&h=555&fit=max)\n\nOf course, this is not your board, but we can have the code working with only a few changes.\n\nFor example, at the beginning of the code, you have the library related to Arduino Sense IMU:\n\n```\n/* Includes --------------------------------------------------------------- */\n#include <XIAO-ESP32S3-Motion-Classification_inferencing.h>\n#include <Arduino_LSM9DS1.h>\n```\n\nChange the \"includes\" portion with the code related to the IMU:\n\n```\n#include <XIAO-ESP32S3-Motion-Classification_inferencing.h>\n#include \"I2Cdev.h\"\n#include \"MPU6050.h\"\n#include \"Wire.h\"\n```\n\nChange the Constant Defines\n\n```\n/* Constant defines ------------------------------------------------------- */\nMPU6050 imu;\nint16_t ax, ay, az;\n\n#define ACC_RANGE           1 // 0: -/+2G; 1: +/-4G\n#define CONVERT_G_TO_MS2    (9.81/(16384/(1.+ACC_RANGE)))\n#define MAX_ACCEPTED_RANGE  (2*9.81)+(2*9.81)*ACC_RANGE\n```\n\nOn the setup function, initiate the IMU set the off-set values and range:\n\n```\n// initialize device\nSerial.println(\"Initializing I2C devices...\");\nWire.begin();\nimu.initialize();\ndelay(10);\n\n//Set MCU 6050 OffSet Calibration \nimu.setXAccelOffset(-4732);\nimu.setYAccelOffset(4703);\nimu.setZAccelOffset(8867);\nimu.setXGyroOffset(61);\nimu.setYGyroOffset(-73);\nimu.setZGyroOffset(35);\n\nimu.setFullScaleAccelRange(ACC_RANGE);\n```\n\nAt the loop function, the buffers buffer[ix], buffer[ix + 1], and  buffer[ix + 2] will receive the 3-axis data captured by the accelerometer. On the original code, you have the line:\n\n```\nIMU.readAcceleration(buffer[ix], buffer[ix + 1], buffer[ix + 2]);\n```\n\nChange it with this block of code:\n\n```\nimu.getAcceleration(&ax, &ay, &az);       \nbuffer[ix + 0] = ax;\nbuffer[ix + 1] = ay;\nbuffer[ix + 2] = az;\n```\n\nYou should change the order of the following two blocks of code. First, you make the conversion to raw data to \"Meters per squared second (ms^2^)\", followed by the test regarding the maximum acceptance range (that here is in ms^2^, but on Arduino, was in Gs):\n\n```\nbuffer[ix + 0] *= CONVERT_G_TO_MS2;\nbuffer[ix + 1] *= CONVERT_G_TO_MS2;\nbuffer[ix + 2] *= CONVERT_G_TO_MS2;\n\nfor (int i = 0; i < 3; i++) {\n     if (fabs(buffer[ix + i]) > MAX_ACCEPTED_RANGE) {\n        buffer[ix + i] = ei_get_sign(buffer[ix + i]) * MAX_ACCEPTED_RANGE;\n     }\n}\n```\n\nAnd that is it!  You can now upload the code to your device and proceed with the inferences. The complete code is available on the [project's GitHub](https://github.com/Mjrovai/XIAO-ESP32S3-Sense/tree/main/IMU).\n\nNow you should try your movements, seeing the result of the inference of each class on the images:\n\n![](images/jpeg/idle-inference.jpg)\n\n![](images/jpeg/terrestrial-inference.jpg)\n\n![](images/jpeg/lift-inference.jpg)\n\n![](images/jpeg/maritime-inference.jpg)\n\nAnd, of course, some \"anomaly\", for example, putting the XIAO upside-down. The anomaly score will be over 1:\n\n![](images/jpeg/anomaly-inference.jpg)\n\n## Conclusion\n\nRegarding the IMU, this project used the low-cost MPU6050 but could also use other IMUs, for example, the LCM20600 (6-axis), which is part of the [Seeed Grove - IMU 9DOF (lcm20600+AK09918)](https://wiki.seeedstudio.com/Grove-IMU_9DOF-lcm20600+AK09918/). You can take advantage of this sensor, which has integrated a Grove connector, which can be helpful in the case you use the [XIAO with an extension board](https://wiki.seeedstudio.com/Seeeduino-XIAO-Expansion-Board/), as shown below:\n\n![](https://hackster.imgix.net/uploads/attachments/1591025/grove-icm2060-small_plZuu0oQ5W.jpg?auto=compress%2Cformat&w=740&h=555&fit=max)\n\nYou can follow the instructions [here](https://wiki.seeedstudio.com/Grove-IMU_9DOF-lcm20600+AK09918/#specification) to connect the IMU with the MCU. Only note that for using the Grove ICM20600 Accelerometer, it is essential to update the files **I2Cdev.cpp** and **I2Cdev.h** that you will download from the [library provided by Seeed Studio](https://github.com/Seeed-Studio/Seeed_ICM20600_AK09918). For that, replace both files from this [link](https://github.com/jrowberg/i2cdevlib/tree/master/Arduino/I2Cdev). You can find a sketch for testing the IMU on the GitHub project: [accelerometer_test.ino](https://github.com/Mjrovai/XIAO-ESP32S3-Sense/tree/main/IMU/accelerometer_test).\n\n> On the projet's GitHub repository, you will find the last version of all codeand other docs: [XIAO-ESP32S3 - IMU](https://github.com/Mjrovai/XIAO-ESP32S3-Sense/tree/main/IMU).\n\n## Resources\n\n- [XIAO ESP32S3 Codes](https://github.com/Mjrovai/XIAO-ESP32S3-Sense)\n\n- [Edge Impulse Spectral Features Block Colab Notebook](https://colab.research.google.com/github/Mjrovai/Arduino_Nicla_Vision/blob/main/Motion_Classification/Edge_Impulse_Spectral_Features_Block.ipynb)\n\n- [Edge Impulse Project](https://studio.edgeimpulse.com/public/226398/live)\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":8,"fig-height":6,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["../../../../../custom_callout.lua"],"reference-location":"margin","highlight-style":"github","toc":true,"toc-depth":4,"include-in-header":{"text":"<script async src=\"https://www.googletagmanager.com/gtag/js?id=G-M21L0CBCVN\"></script>\n<script type=\"module\"  src=\"/scripts/ai_menu/dist/bundle.js\" defer></script>\n"},"citeproc":true,"output-file":"motion_classification.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author, Editor & Curator","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Last Updated","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.33","bibliography":["../../../../../contents/core/introduction/introduction.bib","../../../../../contents/core/ai_for_good/ai_for_good.bib","../../../../../contents/core/benchmarking/benchmarking.bib","../../../../../contents/core/data_engineering/data_engineering.bib","../../../../../contents/core/dl_primer/dl_primer.bib","../../../../../contents/core/efficient_ai/efficient_ai.bib","../../../../../contents/core/ml_systems/ml_systems.bib","../../../../../contents/core/frameworks/frameworks.bib","../../../../../contents/core/generative_ai/generative_ai.bib","../../../../../contents/core/hw_acceleration/hw_acceleration.bib","../../../../../contents/core/ondevice_learning/ondevice_learning.bib","../../../../../contents/core/ops/ops.bib","../../../../../contents/core/optimizations/optimizations.bib","../../../../../contents/core/privacy_security/privacy_security.bib","../../../../../contents/core/responsible_ai/responsible_ai.bib","../../../../../contents/core/robust_ai/robust_ai.bib","../../../../../contents/core/sustainable_ai/sustainable_ai.bib","../../../../../contents/core/training/training.bib","../../../../../contents/core/workflow/workflow.bib","../../../../../contents/core/conclusion/conclusion.bib"],"comments":{"giscus":{"repo":"harvard-edge/cs249r_book"}},"crossref":{"appendix-title":"Appendix","appendix-delim":":","custom":[{"kind":"float","reference-prefix":"Lab","key":"labq","latex-env":"lab"},{"kind":"float","reference-prefix":"Exercise","key":"exr","latex-env":"exr"},{"kind":"float","reference-prefix":"Video","key":"vid","latex-env":"vid"}]},"citation":true,"license":"CC-BY-NC-SA","editor":{"render-on-save":true},"resources":["../../../../../CNAME"],"_quarto-vars":{"email":{"contact":"vj@eecs.harvard.edu","subject":["MLSys Book"],"info":"mailto:vj@eecs.harvard.edu?subject=\"CS249r%20MLSys%20with%20TinyML%20Book%20-%20\""},"title":{"long":"Machine Learning Systems","short":"Machine Learning Systems"}},"lightbox":true,"theme":{"light":["default","../../../../../style.scss","../../../../../style-light.scss"],"dark":["darkly","../../../../../style.scss","../../../../../style-dark.scss"]},"code-block-bg":true,"code-block-border-left":"#A51C30","table":{"classes":["table-striped","table-hover"]},"citation-location":"margin","sidenote":true,"linkcolor":"#A51C30","urlcolor":"#A51C30","anchor-sections":true,"smooth-scroll":false,"citations-hover":false,"footnotes-hover":false,"number-depth":3},"extensions":{"book":{"multiFile":true}}},"titlepage-pdf":{"identifier":{"display-name":"PDF","target-format":"titlepage-pdf","base-format":"pdf","extension-name":"titlepage"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":true,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":["../../../../../_extensions/nmfs-opensci/titlepage/fonts/qualitype/opentype/QTDublinIrish.otf"],"shortcodes":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","filters":["C:\\Users\\kkleinbard\\Documents\\dev\\kai_projects\\tinyml\\tinyML_repo\\dev_10_26\\cs249r_book\\_extensions\\nmfs-opensci\\titlepage\\titlepage-theme.lua","C:\\Users\\kkleinbard\\Documents\\dev\\kai_projects\\tinyml\\tinyML_repo\\dev_10_26\\cs249r_book\\_extensions\\nmfs-opensci\\titlepage\\coverpage-theme.lua","../../../../../custom_callout.lua"],"toc":true,"top-level-division":"chapter","number-sections":true,"toc-depth":3,"cite-method":"citeproc","reference-location":"margin","include-in-header":[{"file":"../../../../../tex/header-includes.tex"}],"output-file":"motion_classification.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"template-partials":["../../../../../_extensions/nmfs-opensci/titlepage/_coverpage.tex","../../../../../_extensions/nmfs-opensci/titlepage/_author-affiliation-themes.tex","../../../../../_extensions/nmfs-opensci/titlepage/_header-footer-date-themes.tex","../../../../../_extensions/nmfs-opensci/titlepage/_title-themes.tex","../../../../../_extensions/nmfs-opensci/titlepage/_titlepage.tex","../../../../../_extensions/nmfs-opensci/titlepage/before-body.tex","../../../../../_extensions/nmfs-opensci/titlepage/pandoc.tex"],"revealjs-plugins":[],"bibliography":["../../../../../contents/core/introduction/introduction.bib","../../../../../contents/core/ai_for_good/ai_for_good.bib","../../../../../contents/core/benchmarking/benchmarking.bib","../../../../../contents/core/data_engineering/data_engineering.bib","../../../../../contents/core/dl_primer/dl_primer.bib","../../../../../contents/core/efficient_ai/efficient_ai.bib","../../../../../contents/core/ml_systems/ml_systems.bib","../../../../../contents/core/frameworks/frameworks.bib","../../../../../contents/core/generative_ai/generative_ai.bib","../../../../../contents/core/hw_acceleration/hw_acceleration.bib","../../../../../contents/core/ondevice_learning/ondevice_learning.bib","../../../../../contents/core/ops/ops.bib","../../../../../contents/core/optimizations/optimizations.bib","../../../../../contents/core/privacy_security/privacy_security.bib","../../../../../contents/core/responsible_ai/responsible_ai.bib","../../../../../contents/core/robust_ai/robust_ai.bib","../../../../../contents/core/sustainable_ai/sustainable_ai.bib","../../../../../contents/core/training/training.bib","../../../../../contents/core/workflow/workflow.bib","../../../../../contents/core/conclusion/conclusion.bib"],"comments":{"giscus":{"repo":"harvard-edge/cs249r_book"}},"crossref":{"appendix-title":"Appendix","appendix-delim":":","custom":[{"kind":"float","reference-prefix":"Lab","key":"labq","latex-env":"lab"},{"kind":"float","reference-prefix":"Exercise","key":"exr","latex-env":"exr"},{"kind":"float","reference-prefix":"Video","key":"vid","latex-env":"vid"}]},"citation":true,"license":"CC-BY-NC-SA","editor":{"render-on-save":true},"resources":["../../../../../CNAME"],"_quarto-vars":{"email":{"contact":"vj@eecs.harvard.edu","subject":["MLSys Book"],"info":"mailto:vj@eecs.harvard.edu?subject=\"CS249r%20MLSys%20with%20TinyML%20Book%20-%20\""},"title":{"long":"Machine Learning Systems","short":"Machine Learning Systems"}},"documentclass":"scrbook","classoption":["abstract","titlepage"],"coverpage":true,"coverpage-title":"Machine Learning Systems","coverpage-bg-image":"../../../../../cover-image-transparent.png","coverpage-author":["Vijay","Janapa Reddi"],"coverpage-theme":{"page-text-align":"center","bg-image-left":"0.225\\paperwidth","bg-image-bottom":7,"bg-image-rotate":0,"bg-image-opacity":1,"author-style":"plain","author-sep":"newline","author-fontsize":20,"author-align":"right","author-bottom":"0.15\\paperwidth","author-left":"7in","author-width":"6in","footer-style":"none","header-style":"none","date-style":"none","title-fontsize":57,"title-left":"0.075\\paperwidth","title-bottom":"0.375\\paperwidth","title-width":"0.9\\paperwidth"},"titlepage":true,"titlepage-theme":{"elements":["\\titleblock","Prof. Vijay Janapa Reddi","School of Engineering and Applied Sciences","Harvard University","\\vfill","With heartfelt gratitude to the community for their invaluable contributions and steadfast support.","\\vfill"],"page-align":"left","title-style":"plain","title-fontstyle":["huge","bfseries"],"title-space-after":"4\\baselineskip","title-subtitle-space-between":"0.05\\textheight","subtitle-fontstyle":["large","textit"],"author-style":"superscript-with-and","author-fontstyle":"large","affiliation-style":"numbered-list-with-correspondence","affiliation-fontstyle":"large","affiliation-space-after":"0pt","footer-style":"plain","footer-fontstyle":"large","logo-size":"0.15\\textheight","logo-space-after":"1\\baselineskip","vrule-width":"2pt","vrule-align":"left","vrule-color":"black"},"lof":false,"lot":false,"latex-engine":"xelatex","citation-package":"natbib","link-citations":true,"biblio-title":"References","title-block-style":"none","indent":"0px","fontsize":"10pt","citation-location":"block","fig-caption":true,"cap-location":"margin","fig-cap-location":"margin","tbl-cap-location":"margin","hyperrefoptions":["linktoc=all","pdfwindowui","pdfpagemode=FullScreen","pdfpagelayout=TwoPageRight"]},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","titlepage-pdf"]}