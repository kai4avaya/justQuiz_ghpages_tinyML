{"title":"Image Classification","markdown":{"headingText":"Image Classification","headingAttr":{"id":"","classes":["unnumbered"],"keyvalue":[]},"containsRefs":false,"markdown":"\n![*DALLÂ·E prompt - A cover image for an 'Image Classification' chapter in a Raspberry Pi tutorial, designed in the same vintage 1950s electronics lab style as previous covers. The scene should feature a Raspberry Pi connected to a camera module, with the camera capturing a photo of the small blue robot provided by the user. The robot should be placed on a workbench, surrounded by classic lab tools like soldering irons, resistors, and wires. The lab background should include vintage equipment like oscilloscopes and tube radios, maintaining the detailed and nostalgic feel of the era. No text or logos should be included.*](images/jpeg/img_class_cover.jpg)\n\n## Overview\n\nImage classification is a fundamental task in computer vision that involves categorizing an image into one of several predefined classes. It's a cornerstone of artificial intelligence, enabling machines to interpret and understand visual information in a way that mimics human perception.\n\nImage classification refers to assigning a label or category to an entire image based on its visual content. This task is crucial in computer vision and has numerous applications across various industries. Image classification's importance lies in its ability to automate visual understanding tasks that would otherwise require human intervention.\n\n### Applications in Real-World Scenarios\n\nImage classification has found its way into numerous real-world applications, revolutionizing various sectors:\n\n- Healthcare: Assisting in medical image analysis, such as identifying abnormalities in X-rays or MRIs.\n- Agriculture: Monitoring crop health and detecting plant diseases through aerial imagery.\n- Automotive: Enabling advanced driver assistance systems and autonomous vehicles to recognize road signs, pedestrians, and other vehicles.\n- Retail: Powering visual search capabilities and automated inventory management systems.\n- Security and Surveillance: Enhancing threat detection and facial recognition systems.\n- Environmental Monitoring: Analyzing satellite imagery for deforestation, urban planning, and climate change studies.\n\n### Advantages of Running Classification on Edge Devices like Raspberry Pi\n\nImplementing image classification on edge devices such as the Raspberry Pi offers several compelling advantages:\n\n1. Low Latency: Processing images locally eliminates the need to send data to cloud servers, significantly reducing response times.\n\n2. Offline Functionality: Classification can be performed without an internet connection, making it suitable for remote or connectivity-challenged environments.\n\n3. Privacy and Security: Sensitive image data remains on the local device, addressing data privacy concerns and compliance requirements.\n\n4. Cost-Effectiveness: Eliminates the need for expensive cloud computing resources, especially for continuous or high-volume classification tasks.\n\n5. Scalability: Enables distributed computing architectures where multiple devices can work independently or in a network.\n\n6. Energy Efficiency: Optimized models on dedicated hardware can be more energy-efficient than cloud-based solutions, which is crucial for battery-powered or remote applications.\n\n7. Customization: Deploying specialized or frequently updated models tailored to specific use cases is more manageable.\n\nWe can create more responsive, secure, and efficient computer vision solutions by leveraging the power of edge devices like Raspberry Pi for image classification. This approach opens up new possibilities for integrating intelligent visual processing into various applications and environments.\n\nIn the following sections, we'll explore how to implement and optimize image classification on the Raspberry Pi, harnessing these advantages to create powerful and efficient computer vision systems.\n\n## Setting Up the Environment\n\n### Updating the Raspberry Pi\n\nFirst, ensure your Raspberry Pi is up to date:\n\n```bash\nsudo apt update\nsudo apt upgrade -y\n```\n\n### Installing Required Libraries\n\nInstall the necessary libraries for image processing and machine learning:\n\n```bash\nsudo apt install python3-pip\nsudo rm /usr/lib/python3.11/EXTERNALLY-MANAGED\npip3 install --upgrade pip\n```\n\n### Setting up a Virtual Environment (Optional but Recommended)\n\nCreate a virtual environment to manage dependencies:\n\n```bash\npython3 -m venv ~/tflite\nsource ~/tflite/bin/activate\n```\n\n### Installing TensorFlow Lite\n\nWe are interested in performing **inference**, which refers to executing a TensorFlow Lite model on a device to make predictions based on input data. To perform an inference with a TensorFlow Lite model, we must run it through an **interpreter**. The TensorFlow Lite interpreter is designed to be lean and fast. The interpreter uses a static graph ordering and a custom (less-dynamic) memory allocator to ensure minimal load, initialization, and execution latency.\n\nWe'll use the [TensorFlow Lite runtime](https://pypi.org/project/tflite-runtime/) for Raspberry Pi, a simplified library for running machine learning models on mobile and embedded devices, without including all TensorFlow packages. \n\n```bash\npip install tflite_runtime --no-deps\n```\n\n> The wheel installed: `tflite_runtime-2.14.0-cp311-cp311-manylinux_2_34_aarch64.whl`\n\n### Installing Additional Python Libraries\n\nInstall required Python libraries for use with Image Classification:\n\nIf you have another version of Numpy installed, first uninstall it.\n\n```bash\npip3 uninstall numpy\n```\n\nInstall `version 1.23.2`, which is compatible with the tflite_runtime. \n\n```bash\n pip3 install numpy==1.23.2\n```\n\n```bash\npip3 install Pillow matplotlib\n```\n\n### Creating a working directory:\n\nIf you are working on the Raspi-Zero with the minimum OS (No Desktop), you may not have a user-pre-defined directory tree (you can check it with `ls`. So, let's create one:\n\n```bash\nmkdir Documents\ncd Documents/\nmkdir TFLITE\ncd TFLITE/\nmkdir IMG_CLASS\ncd IMG_CLASS\nmkdir models\ncd models\n```\n\n> On the Raspi-5, the /Documents should be there. \n\n**Get a pre-trained Image Classification model**:\n\nAn appropriate pre-trained model is crucial for successful image classification on resource-constrained devices like the Raspberry Pi. **MobileNet** is designed for mobile and embedded vision applications with a good balance between accuracy and speed. Versions: MobileNetV1, MobileNetV2, MobileNetV3. Let's download the V2:\n\n```bash\nwget https://storage.googleapis.com/download.tensorflow.org/models/\ntflite_11_05_08/mobilenet_v2_1.0_224_quant.tgz\n\ntar xzf mobilenet_v2_1.0_224_quant.tgz\n```\n\nGet its [labels](https://github.com/Mjrovai/EdgeML-with-Raspberry-Pi/blob/main/IMG_CLASS/models/labels.txt):\n\n```bash\nwget https://github.com/Mjrovai/EdgeML-with-Raspberry-Pi/blob/main/IMG_CLASS/models/labels.txt\n```\n\nIn the end, you should have the models in its directory: \n\n![](images/png/models_dir.png)\n\n> We will only need the `mobilenet_v2_1.0_224_quant.tflite` model and the `labels.txt`. You can delete the other files. \n\n### Setting up Jupyter Notebook (Optional)\n\nIf you prefer using Jupyter Notebook for development:\n\n```bash\npip3 install jupyter\njupyter notebook --generate-config\n```\n\nTo run Jupyter Notebook, run the command (change the IP address for yours):\n\n```bash\njupyter notebook --ip=192.168.4.210 --no-browser\n```\n\nOn the terminal, you can see the local URL address to open the notebook:\n\n![](images/png/notebook_token.png)\n\nYou can access it from another device by entering the Raspberry Pi's IP address and the provided token in a web browser (you can copy the token from the terminal).\n\n![](images/png/image-20240823145059675.png)\n\nDefine your working directory in the Raspi and create a new Python 3 notebook.\n\n### Verifying the Setup\n\nTest your setup by running a simple Python script:\n\n```python\nimport tflite_runtime.interpreter as tflite\nimport numpy as np\nfrom PIL import Image\n\nprint(\"NumPy:\", np.__version__)\nprint(\"Pillow:\", Image.__version__)\n\n# Try to create a TFLite Interpreter\nmodel_path = \"./models/mobilenet_v2_1.0_224_quant.tflite\"\ninterpreter = tflite.Interpreter(model_path=model_path)\ninterpreter.allocate_tensors()\nprint(\"TFLite Interpreter created successfully!\")\n```\n\nYou can create the Python script using nano on the terminal, saving it with `CTRL+0` + `ENTER` + `CTRL+X`\n\n![](images/png/nano.png)\n\nAnd run it with the command:\n\n![](images/png/test_result.png)\n\nOr you can run it directly on the [Notebook](https://github.com/Mjrovai/EdgeML-with-Raspberry-Pi/blob/main/IMG_CLASS/notebooks/setup_test.ipynb):\n\n![](images/png/notebook_test.png)\n\n## Making inferences with Mobilenet V2\n\nIn the last section, we set up the environment, including downloading a popular pre-trained model, Mobilenet V2, trained on ImageNet's 224x224 images (1.2 million) for 1,001 classes (1,000 object categories plus 1 background). The model was converted to a compact 3.5MB TensorFlow Lite format, making it suitable for the limited storage and memory of a Raspberry Pi.\n\n![](images/png/mobilinet_zero.png)\n\nLet's start a new [notebook](https://github.com/Mjrovai/EdgeML-with-Raspberry-Pi/blob/main/IMG_CLASS/notebooks/10_Image_Classification.ipynb) to follow all the steps to classify one image:\n\nImport the needed libraries:\n\n```python\nimport time\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport tflite_runtime.interpreter as tflite\n```\n\nLoad the TFLite model and allocate tensors:\n\n```python\nmodel_path = \"./models/mobilenet_v2_1.0_224_quant.tflite\"\ninterpreter = tflite.Interpreter(model_path=model_path)\ninterpreter.allocate_tensors()\n```\n\nGet input and output tensors.\n\n```python\ninput_details = interpreter.get_input_details()\noutput_details = interpreter.get_output_details()\n```\n\n**Input details** will give us information about how the model should be fed with an image. The shape of (1, 224, 224, 3) informs us that an image with dimensions (224x224x3) should be input one by one (Batch Dimension: 1). \n\n![](images/png/input_details.png)\n\nThe **output details** show that the inference will result in an array of 1,001 integer values. Those values result from the image classification, where each value is the probability of that specific label being related to the image.\n\n![](images/png/output_details.png)\n\nLet's also inspect the dtype of input details of the model\n\n```python\ninput_dtype = input_details[0]['dtype']\ninput_dtype\n```\n\n```\ndtype('uint8')\n```\n\nThis shows that the input image should be raw pixels (0 - 255).\n\nLet's get a test image. You can transfer it from your computer or download one for testing. Let's first create a folder under our working directory:\n\n```bash\nmkdir images\ncd images\nwget https://upload.wikimedia.org/wikipedia/commons/3/3a/Cat03.jpg\n```\n\nLet's load and display  the image:\n\n```python\n# Load he image\nimg_path = \"./images/Cat03.jpg\"\nimg = Image.open(img_path)\n\n# Display the image\nplt.figure(figsize=(8, 8))\nplt.imshow(img)\nplt.title(\"Original Image\")\nplt.show()\n```\n\n![](images/png/cat_original.png)\n\nWe can see the image size running the command:\n\n```python\nwidth, height = img.size\n```\n\nThat shows us that the image is an RGB image with a width of 1600 and a height of 1600 pixels. So, to use our model, we should reshape it to (224, 224, 3) and add a batch dimension of 1, as defined in input details: (1, 224, 224, 3). The inference result, as shown in output details, will be an array with a 1001 size, as shown below:\n\n![](images/png/process_img.png)\n\nSo, let's reshape the image, add the batch dimension, and see the result:\n\n```python\nimg = img.resize((input_details[0]['shape'][1], input_details[0]['shape'][2]))\ninput_data = np.expand_dims(img, axis=0)\ninput_data.shape\n```\n\nThe input_data shape is as expected: (1, 224, 224, 3)\n\nLet's confirm the dtype of the input data:\n\n```python\ninput_data.dtype\n```\n\n```\ndtype('uint8')\n```\n\nThe input data dtype is 'uint8', which is compatible with the dtype expected for the model.\n\nUsing the input_data, let's run the interpreter and get the predictions (output):\n\n```python\ninterpreter.set_tensor(input_details[0]['index'], input_data)\ninterpreter.invoke()\npredictions = interpreter.get_tensor(output_details[0]['index'])[0]\n```\n\nThe prediction is an array with 1001 elements. Let's get the Top-5 indices where their elements have high values:\n\n```python\ntop_k_results = 5\ntop_k_indices = np.argsort(predictions)[::-1][:top_k_results]\ntop_k_indices \n```\n\nThe top_k_indices is an array with 5 elements: `array([283, 286, 282])`\n\nSo, 283, 286, 282, 288, and 479 are the image's most probable classes. Having the index, we must find to what class it appoints (such as car, cat, or dog). The text file downloaded with the model has a label associated with each index from 0 to 1,000. Let's use a function to load the .txt file as a list:\n\n```python\ndef load_labels(filename):\n    with open(filename, 'r') as f:\n        return [line.strip() for line in f.readlines()]\n```\n\nAnd get the list, printing the labels associated with the indexes:\n\n```python\nlabels_path = \"./models/labels.txt\"\nlabels = load_labels(labels_path)\n\nprint(labels[286])\nprint(labels[283])\nprint(labels[282])\nprint(labels[288])\nprint(labels[479])\n```\n\nAs a result, we have:\n\n```bash\nEgyptian cat\ntiger cat\ntabby\nlynx\ncarton\n```\n\nAt least the four top indices are related to felines. The **prediction** content is the probability associated with each one of the labels. As we saw on output details, those values are quantized and should be dequantized and apply softmax. \n\n```python\nscale, zero_point = output_details[0]['quantization']\ndequantized_output = (predictions.astype(np.float32) - zero_point) * scale\nexp_output = np.exp(dequantized_output - np.max(dequantized_output))\nprobabilities = exp_output / np.sum(exp_output)\n```\n\nLet's print the top-5 probabilities:\n\n```python\nprint (probabilities[286])\nprint (probabilities[283])\nprint (probabilities[282])\nprint (probabilities[288])\nprint (probabilities[479])\n```\n\n```bash\n0.27741462\n0.3732285\n0.16919471\n0.10319158\n0.023410844\n```\n\nFor clarity, let's create a function to relate the labels with the probabilities:\n\n```python\nfor i in range(top_k_results):\n    print(\"\\t{:20}: {}%\".format(\n        labels[top_k_indices[i]],\n        (int(probabilities[top_k_indices[i]]*100))))\n```\n\n```bash\ntiger cat           : 37%\nEgyptian cat        : 27%\ntabby               : 16%\nlynx                : 10%\ncarton              : 2%\n```\n\n### Define a general Image Classification function\n\nLet's create a general function to give an image as input, and we get the Top-5 possible classes:\n<div class=\"scroll-code-block\">\n```python\ndef image_classification(img_path, model_path, labels, top_k_results=5):\n    # load the image\n    img = Image.open(img_path)\n    plt.figure(figsize=(4, 4))\n    plt.imshow(img)\n    plt.axis('off')\n\n    # Load the TFLite model\n    interpreter = tflite.Interpreter(model_path=model_path)\n    interpreter.allocate_tensors()\n    \n    # Get input and output tensors\n    input_details = interpreter.get_input_details()\n    output_details = interpreter.get_output_details()\n    \n    # Preprocess\n    img = img.resize((input_details[0]['shape'][1], \n                      input_details[0]['shape'][2]))\n    input_data = np.expand_dims(img, axis=0)\n    \n    # Inference on Raspi-Zero\n    interpreter.set_tensor(input_details[0]['index'], input_data)\n    interpreter.invoke()\n    \n    # Obtain results and map them to the classes\n    predictions = interpreter.get_tensor(output_details[0]['index'])[0]\n    \n    # Get indices of the top k results\n    top_k_indices = np.argsort(predictions)[::-1][:top_k_results]\n    \n    # Get quantization parameters\n    scale, zero_point = output_details[0]['quantization']\n    \n    # Dequantize the output and apply softmax\n    dequantized_output = (predictions.astype(np.float32) - zero_point) * scale\n    exp_output = np.exp(dequantized_output - np.max(dequantized_output))\n    probabilities = exp_output / np.sum(exp_output)\n    \n    print(\"\\n\\t[PREDICTION]        [Prob]\\n\")\n    for i in range(top_k_results):\n        print(\"\\t{:20}: {}%\".format(\n            labels[top_k_indices[i]],\n            (int(probabilities[top_k_indices[i]]*100))))\n```\n</div>\nAnd loading some images for testing, we have:\n\n![](images/jpeg/img_class_func.jpg)\n\n### Testing with a model trained from scratch\n\nLet's get a TFLite model trained from scratch. For that, you can follow the Notebook: \n\n[CNN to classify Cifar-10 dataset](https://colab.research.google.com/github/Mjrovai/UNIFEI-IESTI01-TinyML-2022.1/blob/main/00_Curse_Folder/2_Applications_Deploy/Class_16/cifar_10/CNN_Cifar_10_TFLite.ipynb#scrollTo=iiVBUpuHXEtw)\n\n In the notebook, we trained a model using the CIFAR10 dataset, which contains 60,000 images from 10 classes of CIFAR (*airplane, automobile, bird, cat, deer, dog, frog, horse, ship, and truck*). CIFAR has 32x32 color images (3 color channels) where the objects are not centered and can have the object with a background, such as airplanes that might have a cloudy sky behind them! In short, small but real images. \n\nThe CNN trained model (*cifar10_model.keras*) had a size of 2.0MB. Using the *TFLite Converter*, the model *cifar10.tflite* became with 674MB (around 1/3 of the original size). \n\n![](images/png/cifar10_model.png)\n\nOn the notebook [Cifar 10 - Image Classification on a Raspi with TFLite](https://github.com/Mjrovai/EdgeML-with-Raspberry-Pi/blob/main/IMG_CLASS/notebooks/20_Cifar_10_Image_Classification.ipynb) (which can be run over the Raspi), we can follow the same steps we did with the `mobilenet_v2_1.0_224_quant.tflite`. Below are examples of images using the *General Function for Image Classification* on a Raspi-Zero, as shown in the last section.\n\n![](images/png/infer-cifar10.png)\n\n\n\n### Installing Picamera2\n\n[Picamera2](https://github.com/raspberrypi/picamera2), a Python library for interacting with Raspberry Pi's camera, is based on the *libcamera* camera stack, and the Raspberry Pi foundation maintains it. The Picamera2 library is supported on all Raspberry Pi models, from the Pi Zero to the RPi 5. It is already installed system-wide on the Raspi, but we should make it accessible within the virtual environment.\n\n1. First, activate the virtual environment if it's not already activated:\n\n    ```bash\n    source ~/tflite/bin/activate\n```\n\n2. Now, let's create a .pth file in your virtual environment to add the system site-packages path:\n\n    ```bash\n    echo \"/usr/lib/python3/dist-packages\" > $VIRTUAL_ENV/lib/python3.11/\n    site-packages/system_site_packages.pth\n    ```\n\n    > Note: If your Python version differs, replace  `python3.11` with the appropriate version.\n\n3. After creating this file, try importing picamera2 in Python:\n\n    ```bash\n    python3\n    >>> import picamera2\n    >>> print(picamera2.__file__)\n    ```\n\nThe above code will show the file location of the `picamera2` module itself, proving that the library can be accessed from the environment. \n\n```python\n/home/mjrovai/tflite/lib/python3.11/site-packages/picamera2/__init__.py\n```\n\nYou can also list the available cameras in the system:\n\n```python\n>>> print(Picamera2.global_camera_info())\n```\n\nIn my case, with a USB installed, I got:\n\n![](images/png/cam_installed.png)\n\nNow that we've confirmed picamera2 is working in the environment with an `index 0`,  let's try a simple Python script to capture an image from your USB camera:\n\n```python\nfrom picamera2 import Picamera2\nimport time\n\n# Initialize the camera\npicam2 = Picamera2() # default is index 0\n\n# Configure the camera\nconfig = picam2.create_still_configuration(main={\"size\": (640, 480)})\npicam2.configure(config)\n\n# Start the camera\npicam2.start()\n\n# Wait for the camera to warm up\ntime.sleep(2)\n\n# Capture an image\npicam2.capture_file(\"usb_camera_image.jpg\")\nprint(\"Image captured and saved as 'usb_camera_image.jpg'\")\n\n# Stop the camera\npicam2.stop()\n```\n\nUse the Nano text editor, the Jupyter Notebook, or any other editor. Save this as a Python script (e.g., `capture_image.py`) and run it. This should capture an image from your camera and save it as \"usb_camera_image.jpg\" in the same directory as your script.\n\n![](images/png/capture_test.png)\n\nIf the Jupyter is open, you can see the captured image on your computer. Otherwise, transfer the file from the Raspi to your computer.  \n\n![](images/png/img_test_result.png)\n\n> If you are working with a Raspi-5 with a whole desktop, you can open the file directly on the device. \n\n## Image Classification Project\n\nNow, we will develop a complete Image Classification project using the Edge Impulse Studio. As we did with the Movilinet V2, the trained and converted TFLite model will be used for inference. \n\n### The Goal\n\nThe first step in any ML project is to define its goal. In this case, it is to detect and classify two specific objects present in one image. For this project, we will use two small toys: a robot and a small Brazilian parrot (named Periquito). We will also collect images of a *background* where those two objects are absent.\n\n![](images/jpeg/project_goal.jpg)\n\n### Data Collection\n\nOnce we have defined our Machine Learning project goal, the next and most crucial step is collecting the dataset. We can use a phone for the image capture, but we will use the Raspi here. Let's set up a simple web server on our Raspberry Pi to view the `QVGA (320 x 240)` captured images in a browser. \n\n1. First, let's install Flask, a lightweight web framework for Python:\n\n    ```bash\n    pip3 install flask\n    ```\n\n2. Let's create a new Python script combining image capture with a web server.  We'll call it `get_img_data.py`:\n\n<div class=\"scroll-code-block\">\n\n```python\nfrom flask import Flask, Response, render_template_string, request, redirect, url_for\nfrom picamera2 import Picamera2\nimport io\nimport threading\nimport time\nimport os\nimport signal\n\napp = Flask(__name__)\n\n# Global variables\nbase_dir = \"dataset\"\npicam2 = None\nframe = None\nframe_lock = threading.Lock()\ncapture_counts = {}\ncurrent_label = None\nshutdown_event = threading.Event()\n\ndef initialize_camera():\n    global picam2\n    picam2 = Picamera2()\n    config = picam2.create_preview_configuration(main={\"size\": (320, 240)})\n    picam2.configure(config)\n    picam2.start()\n    time.sleep(2)  # Wait for camera to warm up\n\ndef get_frame():\n    global frame\n    while not shutdown_event.is_set():\n        stream = io.BytesIO()\n        picam2.capture_file(stream, format='jpeg')\n        with frame_lock:\n            frame = stream.getvalue()\n        time.sleep(0.1)  # Adjust as needed for smooth preview\n\ndef generate_frames():\n    while not shutdown_event.is_set():\n        with frame_lock:\n            if frame is not None:\n                yield (b'--frame\\r\\n'\n                       b'Content-Type: image/jpeg\\r\\n\\r\\n' + frame + b'\\r\\n')\n        time.sleep(0.1)  # Adjust as needed for smooth streaming\n\ndef shutdown_server():\n    shutdown_event.set()\n    if picam2:\n        picam2.stop()\n    # Give some time for other threads to finish\n    time.sleep(2)\n    # Send SIGINT to the main process\n    os.kill(os.getpid(), signal.SIGINT)\n\n@app.route('/', methods=['GET', 'POST'])\ndef index():\n    global current_label\n    if request.method == 'POST':\n        current_label = request.form['label']\n        if current_label not in capture_counts:\n            capture_counts[current_label] = 0\n        os.makedirs(os.path.join(base_dir, current_label), exist_ok=True)\n        return redirect(url_for('capture_page'))\n    return render_template_string('''\n        <!DOCTYPE html>\n        <html>\n        <head>\n            <title>Dataset Capture - Label Entry</title>\n        </head>\n        <body>\n            <h1>Enter Label for Dataset</h1>\n            <form method=\"post\">\n                <input type=\"text\" name=\"label\" required>\n                <input type=\"submit\" value=\"Start Capture\">\n            </form>\n        </body>\n        </html>\n    ''')\n\n@app.route('/capture')\ndef capture_page():\n    return render_template_string('''\n        <!DOCTYPE html>\n        <html>\n        <head>\n            <title>Dataset Capture</title>\n            <script>\n                var shutdownInitiated = false;\n                function checkShutdown() {\n                    if (!shutdownInitiated) {\n                        fetch('/check_shutdown')\n                            .then(response => response.json())\n                            .then(data => {\n                                if (data.shutdown) {\n                                    shutdownInitiated = true;\n                                    document.getElementById('video-feed').src = '';\n                                    document.getElementById('shutdown-message')\n                                    .style.display = 'block';\n                                }\n                            });\n                    }\n                }\n                setInterval(checkShutdown, 1000);  // Check every second\n            </script>\n        </head>\n        <body>\n            <h1>Dataset Capture</h1>\n            <p>Current Label: {{ label }}</p>\n            <p>Images captured for this label: {{ capture_count }}</p>\n            <img id=\"video-feed\" src=\"{{ url_for('video_feed') }}\" width=\"640\" \n            height=\"480\" />\n            <div id=\"shutdown-message\" style=\"display: none; color: red;\">\n                Capture process has been stopped. You can close this window.\n            </div>\n            <form action=\"/capture_image\" method=\"post\">\n                <input type=\"submit\" value=\"Capture Image\">\n            </form>\n            <form action=\"/stop\" method=\"post\">\n                <input type=\"submit\" value=\"Stop Capture\" \n                style=\"background-color: #ff6666;\">\n            </form>\n            <form action=\"/\" method=\"get\">\n                <input type=\"submit\" value=\"Change Label\" \n                style=\"background-color: #ffff66;\">\n            </form>\n        </body>\n        </html>\n    ''', label=current_label, capture_count=capture_counts.get(current_label, 0))\n\n@app.route('/video_feed')\ndef video_feed():\n    return Response(generate_frames(),\n                    mimetype='multipart/x-mixed-replace; boundary=frame')\n\n@app.route('/capture_image', methods=['POST'])\ndef capture_image():\n    global capture_counts\n    if current_label and not shutdown_event.is_set():\n        capture_counts[current_label] += 1\n        timestamp = time.strftime(\"%Y%m%d-%H%M%S\")\n        filename = f\"image_{timestamp}.jpg\"\n        full_path = os.path.join(base_dir, current_label, filename)\n        \n        picam2.capture_file(full_path)\n    \n    return redirect(url_for('capture_page'))\n\n@app.route('/stop', methods=['POST'])\ndef stop():\n    summary = render_template_string('''\n        <!DOCTYPE html>\n        <html>\n        <head>\n            <title>Dataset Capture - Stopped</title>\n        </head>\n        <body>\n            <h1>Dataset Capture Stopped</h1>\n            <p>The capture process has been stopped. You can close this window.</p>\n            <p>Summary of captures:</p>\n            <ul>\n            {% for label, count in capture_counts.items() %}\n                <li>{{ label }}: {{ count }} images</li>\n            {% endfor %}\n            </ul>\n        </body>\n        </html>\n    ''', capture_counts=capture_counts)\n    \n    # Start a new thread to shutdown the server\n    threading.Thread(target=shutdown_server).start()\n    \n    return summary\n\n@app.route('/check_shutdown')\ndef check_shutdown():\n    return {'shutdown': shutdown_event.is_set()}\n\nif __name__ == '__main__':\n    initialize_camera()\n    threading.Thread(target=get_frame, daemon=True).start()\n    app.run(host='0.0.0.0', port=5000, threaded=True)\n```\n</div>\n\n3. Run this script:\n\n    ```bash\n    python3 get_img_data.py\n```\n\n4. Access the web interface:\n\n    - On the Raspberry Pi itself (if you have a GUI): Open a web browser and go to `http://localhost:5000`\n    - From another device on the same network: Open a web browser and go to `http://<raspberry_pi_ip>:5000` (Replace `<raspberry_pi_ip>` with your Raspberry Pi's IP address). For example: `http://192.168.4.210:5000/`\n\nThis Python script creates a web-based interface for capturing and organizing image datasets using a Raspberry Pi and its camera. It's handy for machine learning projects that require labeled image data.\n\n#### Key Features:\n\n1. **Web Interface**: Accessible from any device on the same network as the Raspberry Pi.\n2. **Live Camera Preview**: This shows a real-time feed from the camera.\n3. **Labeling System**: Allows users to input labels for different categories of images.\n4. **Organized Storage**: Automatically saves images in label-specific subdirectories.\n5. **Per-Label Counters**: Keeps track of how many images are captured for each label.\n6. **Summary Statistics**: Provides a summary of captured images when stopping the capture process.\n\n#### Main Components:\n\n1. **Flask Web Application**: Handles routing and serves the web interface.\n2. **Picamera2 Integration**: Controls the Raspberry Pi camera.\n3. **Threaded Frame Capture**: Ensures smooth live preview.\n4. **File Management**: Organizes captured images into labeled directories.\n\n#### Key Functions:\n\n- `initialize_camera()`: Sets up the Picamera2 instance.\n- `get_frame()`: Continuously captures frames for the live preview.\n- `generate_frames()`: Yields frames for the live video feed.\n- `shutdown_server()`: Sets the shutdown event, stops the camera, and shuts down the Flask server\n- `index()`: Handles the label input page.\n- `capture_page()`: Displays the main capture interface.\n- `video_feed()`: Shows a live preview to position the camera\n- `capture_image()`: Saves an image with the current label.\n- `stop()`: Stops the capture process and displays a summary.\n\n#### Usage Flow:\n\n1. Start the script on your Raspberry Pi.\n2. Access the web interface from a browser.\n3. Enter a label for the images you want to capture and press `Start Capture`.\n\n![](images/png/enter_label.png)\n\n4. Use the live preview to position the camera.\n5. Click `Capture Image` to save images under the current label.\n\n![](images/png/capture.png)\n\n6. Change labels as needed for different categories, selecting `Change Label`.\n7. Click `Stop Capture` when finished to see a summary.\n\n![](images/png/stop.png)\n\n#### Technical Notes:\n\n- The script uses threading to handle concurrent frame capture and web serving.\n- Images are saved with timestamps in their filenames for uniqueness.\n- The web interface is responsive and can be accessed from mobile devices.\n\n#### Customization Possibilities:\n\n- Adjust image resolution in the `initialize_camera()` function. Here we used QVGA (320X240).\n- Modify the HTML templates for a different look and feel.\n- Add additional image processing or analysis steps in the `capture_image()` function.\n\n#### Number of samples on Dataset:\n\nGet around 60 images from each category (`periquito`, `robot` and `background`). Try to capture different angles, backgrounds, and light conditions. On the Raspi, we will end with a folder named `dataset`, witch contains 3 sub-folders *periquito,* *robot*, and *background*. one for each class of images.\n\nYou can use `Filezilla` to transfer the created dataset to your main computer. \n\n## Training the model with Edge Impulse Studio\n\nWe will use the Edge Impulse Studio to train our model. Go to the  [Edge Impulse Page](https://edgeimpulse.com/), enter your account credentials, and create a new project:\n\n![](images/png/new-proj-ei.png)\n\n> Here, you can clone a similar project: [Raspi - Img Class](https://studio.edgeimpulse.com/public/510251/live).\n\n### Dataset\n\nWe will walk through four main steps using the EI Studio (or Studio). These steps are crucial in preparing our model for use on the Raspi: Dataset, Impulse, Tests, and Deploy (on the Edge Device, in this case, the Raspi).\n\n> Regarding the Dataset, it is essential to point out that our Original Dataset, captured with the Raspi, will be split into *Training*, *Validation*, and *Test*. The Test Set will be separated from the beginning and reserved for use only in the Test phase after training. The Validation Set will be used during training.\n\nOn Studio, follow the steps to upload the captured data:\n\n1. Go to the `Data acquisition` tab, and in the `UPLOAD DATA` section, upload the files from your computer in the chosen categories.\n2. Leave to the Studio the splitting of the original dataset into *train and test* and choose the label about\n3. Repeat the procedure for all three classes. At the end, you should see your \"raw data\" in the Studio:\n\n![](images/png/data-Aquisition.png)\n\nThe Studio allows you to explore your data, showing a complete view of all the data in your project. You can clear, inspect, or change labels by clicking on individual data items. In our case, a straightforward project, the data seems OK.\n\n![](images/png/data-esplorer.png)\n\n## The Impulse Design\n\nIn this phase, we should define how to:\n\n- Pre-process our data, which consists of resizing the individual images and determining the `color depth` to use (be it RGB or Grayscale) and\n\n- Specify a Model. In this case, it will be the `Transfer Learning (Images)` to fine-tune a pre-trained MobileNet V2 image classification model on our data. This method performs well even with relatively small image datasets (around 180 images in our case).\n\nTransfer Learning with MobileNet offers a streamlined approach to model training, which is especially beneficial for resource-constrained environments and projects with limited labeled data. MobileNet, known for its lightweight architecture, is a pre-trained model that has already learned valuable features from a large dataset (ImageNet).\n\n![](images/jpeg/model_1.jpg)\n\nBy leveraging these learned features, we can train a new model for your specific task with fewer data and computational resources and achieve competitive accuracy.\n\n![](images/jpeg/model_2.jpg)\n\nThis approach significantly reduces training time and computational cost, making it ideal for quick prototyping and deployment on embedded devices where efficiency is paramount.\n\nGo to the Impulse Design Tab and create the *impulse*, defining an image size of 160x160 and squashing them (squared form, without cropping). Select Image and Transfer Learning blocks. Save the Impulse.\n\n![](images/png/impulse.png)\n\n### Image Pre-Processing\n\nAll the input QVGA/RGB565 images will be converted to 76,800 features (160x160x3).\n\n![](images/png/preproc.png)\n\nPress `Save parameters` and select `Generate features` in the next tab.\n\n### Model Design\n\nMobileNet is a family of efficient convolutional neural networks designed for mobile and embedded vision applications. The key features of MobileNet are:\n\n1. Lightweight: Optimized for mobile devices and embedded systems with limited computational resources.\n2. Speed: Fast inference times, suitable for real-time applications.\n3. Accuracy: Maintains good accuracy despite its compact size.\n\n[MobileNetV2](https://arxiv.org/abs/1801.04381), introduced in 2018, improves the original MobileNet architecture. Key features include:\n\n1. Inverted Residuals: Inverted residual structures are used where shortcut connections are made between thin bottleneck layers.\n2. Linear Bottlenecks: Removes non-linearities in the narrow layers to prevent the destruction of information.\n3. Depth-wise Separable Convolutions: Continues to use this efficient operation from MobileNetV1.\n\nIn our project, we will do a `Transfer Learning` with the `MobileNetV2 160x160 1.0`,  which means that the images used for training (and future inference) should have an *input Size* of 160x160 pixels and a *Width Multiplier* of 1.0 (full width, not reduced). This configuration balances between model size, speed, and accuracy.\n\n### Model Training\n\nAnother valuable deep learning technique is **Data Augmentation**. Data augmentation improves the accuracy of machine learning models by creating additional artificial data. A data augmentation system makes small, random changes to the training data during the training process (such as flipping, cropping, or rotating the images).\n\nLooking under the hood, here you can see how Edge Impulse implements a data Augmentation policy on your data:\n\n``` python\n# Implements the data augmentation policy\ndef augment_image(image, label):\n    # Flips the image randomly\n    image = tf.image.random_flip_left_right(image)\n\n    # Increase the image size, then randomly crop it down to\n    # the original dimensions\n    resize_factor = random.uniform(1, 1.2)\n    new_height = math.floor(resize_factor * INPUT_SHAPE[0])\n    new_width = math.floor(resize_factor * INPUT_SHAPE[1])\n    image = tf.image.resize_with_crop_or_pad(image, new_height, new_width)\n    image = tf.image.random_crop(image, size=INPUT_SHAPE)\n\n    # Vary the brightness of the image\n    image = tf.image.random_brightness(image, max_delta=0.2)\n\n    return image, label\n```\n\nExposure to these variations during training can help prevent your model from taking shortcuts by \"memorizing\" superficial clues in your training data, meaning it may better reflect the deep underlying patterns in your dataset.\n\nThe final dense layer of our model will have 0 neurons with a 10% dropout for overfitting prevention. Here is the Training result:\n\n![](images/png/result-train.png)\n\nThe result is excellent, with a reasonable 35ms of latency (for a Raspi-4), which should result in around 30 fps (frames per second) during inference. A Raspi-Zero should be slower, and the Raspi-5, faster. \n\n### Trading off: Accuracy versus speed\n\nIf faster inference is needed, we should train the model using smaller alphas (0.35, 0.5, and 0.75) or even reduce the image input size, trading with accuracy. However, reducing the input image size and decreasing the alpha (width multiplier) can speed up inference for MobileNet V2, but they have different trade-offs. Let's compare:\n\n1. Reducing Image Input Size:\n\nPros:\n\n- Significantly reduces the computational cost across all layers.\n- Decreases memory usage.\n- It often provides a substantial speed boost.\n\nCons:\n\n- It may reduce the model's ability to detect small features or fine details.\n- It can significantly impact accuracy, especially for tasks requiring fine-grained recognition.\n\n2. Reducing Alpha (Width Multiplier):\n\nPros:\n\n- Reduces the number of parameters and computations in the model.\n- Maintains the original input resolution, potentially preserving more detail.\n- It can provide a good balance between speed and accuracy.\n\nCons:\n\n- It may not speed up inference as dramatically as reducing input size.\n- It can reduce the model's capacity to learn complex features.\n\nComparison:\n\n1. Speed Impact: \n    - Reducing input size often provides a more substantial speed boost because it reduces computations quadratically (halving both width and height reduces computations by about 75%).\n    - Reducing alpha provides a more linear reduction in computations.\n\n2. Accuracy Impact:\n    - Reducing input size can severely impact accuracy, especially when detecting small objects or fine details.\n    - Reducing alpha tends to have a more gradual impact on accuracy.\n\n3. Model Architecture:\n    - Changing input size doesn't alter the model's architecture.\n    - Changing alpha modifies the model's structure by reducing the number of channels in each layer.\n\nRecommendation:\n\n1. If our application doesn't require detecting tiny details and can tolerate some loss in accuracy, reducing the input size is often the most effective way to speed up inference.\n2. Reducing alpha might be preferable if maintaining the ability to detect fine details is crucial or if you need a more balanced trade-off between speed and accuracy.\n3. For best results, you might want to experiment with both:\n    - Try MobileNet V2 with input sizes like 160x160 or 92x92\n    - Experiment with alpha values like 1.0, 0.75, 0.5 or 0.35.\n4. Always benchmark the different configurations on your specific hardware and with your particular dataset to find the optimal balance for your use case.\n\n> Remember, the best choice depends on your specific requirements for accuracy, speed, and the nature of the images you're working with. It's often worth experimenting with combinations to find the optimal configuration for your particular use case.\n\n### Model Testing\n\nNow, you should take the data set aside at the start of the project and run the trained model using it as input. Again, the result is excellent (92.22%).\n\n### Deploying the model\n\nAs we did in the previous section, we can deploy the trained model as .tflite and use Raspi to run it using Python.\n\nOn the `Dashboard` tab, go to Transfer learning model (int8 quantized) and click on the download icon:\n\n![](images/png/model.png)\n\n> Let's also download the float32 version for comparasion\n\nTransfer the model from your computer to the Raspi (./models), for example, using FileZilla. Also, capture some images for inference (./images). \n\nImport the needed libraries:\n\n```python\nimport time\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport tflite_runtime.interpreter as tflite\n```\n\nDefine the paths and labels:\n\n```python\nimg_path = \"./images/robot.jpg\"\nmodel_path = \"./models/ei-raspi-img-class-int8-quantized-model.tflite\"\nlabels = ['background', 'periquito', 'robot']\n```\n\n> Note that the models trained on the Edge Impulse Studio will output values with index 0, 1, 2, etc., where the actual labels will follow an alphabetic order.\n\nLoad the model, allocate the tensors, and get the input and output tensor details:\n\n```python\n# Load the TFLite model\ninterpreter = tflite.Interpreter(model_path=model_path)\ninterpreter.allocate_tensors()\n\n# Get input and output tensors\ninput_details = interpreter.get_input_details()\noutput_details = interpreter.get_output_details()\n```\n\nOne important difference to note is that the `dtype` of the input details of the model is now `int8`, which means that the input values go from -128 to +127, while each pixel of our image goes from 0 to 255. This means that we should pre-process the image to match it. We can check here:\n\n```python\ninput_dtype = input_details[0]['dtype']\ninput_dtype\n```\n\n```\nnumpy.int8\n```\n\nSo, let's open the image and show it:\n\n```python\nimg = Image.open(img_path)\nplt.figure(figsize=(4, 4))\nplt.imshow(img)\nplt.axis('off')\nplt.show()\n```\n\n![](images/png/infer_robot.png)\n\nAnd perform the pre-processing:\n\n```python\nscale, zero_point = input_details[0]['quantization']\nimg = img.resize((input_details[0]['shape'][1], \n                  input_details[0]['shape'][2]))\nimg_array = np.array(img, dtype=np.float32) / 255.0\nimg_array = (img_array / scale + zero_point).clip(-128, 127).astype(np.int8)\ninput_data = np.expand_dims(img_array, axis=0)\n```\n\nChecking the input data, we can verify that the input tensor is compatible with what is expected by the model:\n\n```python\ninput_data.shape, input_data.dtype\n```\n\n```\n((1, 160, 160, 3), dtype('int8'))\n```\n\nNow, it is time to perform the inference. Let's also calculate the latency of the model:\n\n```python\n# Inference on Raspi-Zero\nstart_time = time.time()\ninterpreter.set_tensor(input_details[0]['index'], input_data)\ninterpreter.invoke()\nend_time = time.time()\ninference_time = (end_time - start_time) * 1000  # Convert to milliseconds\nprint (\"Inference time: {:.1f}ms\".format(inference_time))\n```\n\nThe model will take around 125ms to perform the inference in the Raspi-Zero, which is 3 to 4 times longer than a Raspi-5.\n\nNow, we can get the output labels and probabilities. It is also important to note that the model trained on the Edge Impulse Studio has a softmax in its output (different from the original Movilenet V2), and we should use the model's raw output as the âprobabilities.â\n\n```python\n# Obtain results and map them to the classes\npredictions = interpreter.get_tensor(output_details[0]['index'])[0]\n\n# Get indices of the top k results\ntop_k_results=3\ntop_k_indices = np.argsort(predictions)[::-1][:top_k_results]\n\n# Get quantization parameters\nscale, zero_point = output_details[0]['quantization']\n\n# Dequantize the output\ndequantized_output = (predictions.astype(np.float32) - zero_point) * scale\nprobabilities = dequantized_output\n\nprint(\"\\n\\t[PREDICTION]        [Prob]\\n\")\nfor i in range(top_k_results):\n    print(\"\\t{:20}: {:.2f}%\".format(\n        labels[top_k_indices[i]],\n        probabilities[top_k_indices[i]] * 100))\n```\n\n![](images/png/infer-result.png)\n\nLet's modify the function created before so that we can handle different type of models:\n\n<div class=\"scroll-code-block\">\n```python\ndef image_classification(img_path, model_path, labels, top_k_results=3, \n                         apply_softmax=False):\n    # Load the image\n    img = Image.open(img_path)\n    plt.figure(figsize=(4, 4))\n    plt.imshow(img)\n    plt.axis('off')\n\n    # Load the TFLite model\n    interpreter = tflite.Interpreter(model_path=model_path)\n    interpreter.allocate_tensors()\n    \n    # Get input and output tensors\n    input_details = interpreter.get_input_details()\n    output_details = interpreter.get_output_details()\n    \n    # Preprocess\n    img = img.resize((input_details[0]['shape'][1], \n                      input_details[0]['shape'][2]))\n    \n    input_dtype = input_details[0]['dtype']\n    \n    if input_dtype == np.uint8:\n        input_data = np.expand_dims(np.array(img), axis=0)\n    elif input_dtype == np.int8:\n        scale, zero_point = input_details[0]['quantization']\n        img_array = np.array(img, dtype=np.float32) / 255.0\n        img_array = (img_array / scale + zero_point).clip(-128, 127).astype(np.int8)\n        input_data = np.expand_dims(img_array, axis=0)\n    else:  # float32\n        input_data = np.expand_dims(np.array(img, dtype=np.float32), axis=0) / 255.0\n    \n    # Inference on Raspi-Zero\n    start_time = time.time()\n    interpreter.set_tensor(input_details[0]['index'], input_data)\n    interpreter.invoke()\n    end_time = time.time()\n    inference_time = (end_time - start_time) * 1000  # Convert to milliseconds\n    \n    # Obtain results\n    predictions = interpreter.get_tensor(output_details[0]['index'])[0]\n    \n    # Get indices of the top k results\n    top_k_indices = np.argsort(predictions)[::-1][:top_k_results]\n    \n    # Handle output based on type\n    output_dtype = output_details[0]['dtype']\n    if output_dtype in [np.int8, np.uint8]:\n        # Dequantize the output\n        scale, zero_point = output_details[0]['quantization']\n        predictions = (predictions.astype(np.float32) - zero_point) * scale\n    \n    if apply_softmax:\n        # Apply softmax\n        exp_preds = np.exp(predictions - np.max(predictions))\n        probabilities = exp_preds / np.sum(exp_preds)\n    else:\n        probabilities = predictions\n    \n    print(\"\\n\\t[PREDICTION]        [Prob]\\n\")\n    for i in range(top_k_results):\n        print(\"\\t{:20}: {:.1f}%\".format(\n            labels[top_k_indices[i]],\n            probabilities[top_k_indices[i]] * 100))\n    print (\"\\n\\tInference time: {:.1f}ms\".format(inference_time))\n\n```\n</div>\n\nAnd test it with different images and the int8 quantized model (**160x160 alpha =1.0**). \n\n![](images/png/infer-int8-160.png)\n\nLet's download a smaller model, such as the one trained for the [Nicla Vision Lab](https://studio.edgeimpulse.com/public/353482/live) (int8 quantized model, 96x96, alpha = 0.1), as a test. We can use the same function:\n\n![](images/png/infer-int8-96.png)\n\nThe model lost some accuracy, but it is still OK once our model does not look for many details. Regarding latency, we are around **ten times faster** on the Raspi-Zero. \n\n## Live Image Classification\n\nLet's develop an app to capture images with the USB camera in real time, showing its classification. \n\nUsing the nano on the terminal, save the code below, such as `img_class_live_infer.py`. \n<div class=\"scroll-code-block\">\n```python\nfrom flask import Flask, Response, render_template_string, request, jsonify\nfrom picamera2 import Picamera2\nimport io\nimport threading\nimport time\nimport numpy as np\nfrom PIL import Image\nimport tflite_runtime.interpreter as tflite\nfrom queue import Queue\n\napp = Flask(__name__)\n\n# Global variables\npicam2 = None\nframe = None\nframe_lock = threading.Lock()\nis_classifying = False\nconfidence_threshold = 0.8\nmodel_path = \"./models/ei-raspi-img-class-int8-quantized-model.tflite\"\nlabels = ['background', 'periquito', 'robot']\ninterpreter = None\nclassification_queue = Queue(maxsize=1)\n\ndef initialize_camera():\n    global picam2\n    picam2 = Picamera2()\n    config = picam2.create_preview_configuration(main={\"size\": (320, 240)})\n    picam2.configure(config)\n    picam2.start()\n    time.sleep(2)  # Wait for camera to warm up\n\ndef get_frame():\n    global frame\n    while True:\n        stream = io.BytesIO()\n        picam2.capture_file(stream, format='jpeg')\n        with frame_lock:\n            frame = stream.getvalue()\n        time.sleep(0.1)  # Capture frames more frequently\n\ndef generate_frames():\n    while True:\n        with frame_lock:\n            if frame is not None:\n                yield (b'--frame\\r\\n'\n                       b'Content-Type: image/jpeg\\r\\n\\r\\n' + frame + b'\\r\\n')\n        time.sleep(0.1)\n\ndef load_model():\n    global interpreter\n    if interpreter is None:\n        interpreter = tflite.Interpreter(model_path=model_path)\n        interpreter.allocate_tensors()\n    return interpreter\n\ndef classify_image(img, interpreter):\n    input_details = interpreter.get_input_details()\n    output_details = interpreter.get_output_details()\n\n    img = img.resize((input_details[0]['shape'][1], \n                      input_details[0]['shape'][2]))\n    input_data = np.expand_dims(np.array(img), axis=0)\\\n    \t\t\t\t\t\t .astype(input_details[0]['dtype'])\n\n    interpreter.set_tensor(input_details[0]['index'], input_data)\n    interpreter.invoke()\n\n    predictions = interpreter.get_tensor(output_details[0]['index'])[0]\n    # Handle output based on type\n    output_dtype = output_details[0]['dtype']\n    if output_dtype in [np.int8, np.uint8]:\n        # Dequantize the output\n        scale, zero_point = output_details[0]['quantization']\n        predictions = (predictions.astype(np.float32) - zero_point) * scale\n    return predictions\n\ndef classification_worker():\n    interpreter = load_model()\n    while True:\n        if is_classifying:\n            with frame_lock:\n                if frame is not None:\n                    img = Image.open(io.BytesIO(frame))\n            predictions = classify_image(img, interpreter)\n            max_prob = np.max(predictions)\n            if max_prob >= confidence_threshold:\n                label = labels[np.argmax(predictions)]\n            else:\n                label = 'Uncertain'\n            classification_queue.put({'label': label, \n                                      'probability': float(max_prob)})\n        time.sleep(0.1)  # Adjust based on your needs\n\n@app.route('/')\ndef index():\n    return render_template_string('''\n        <!DOCTYPE html>\n        <html>\n        <head>\n            <title>Image Classification</title>\n            <script \n            \tsrc=\"https://code.jquery.com/jquery-3.6.0.min.js\">\n            </script>\n            <script>\n                function startClassification() {\n                    $.post('/start');\n                    $('#startBtn').prop('disabled', true);\n                    $('#stopBtn').prop('disabled', false);\n                }\n                function stopClassification() {\n                    $.post('/stop');\n                    $('#startBtn').prop('disabled', false);\n                    $('#stopBtn').prop('disabled', true);\n                }\n                function updateConfidence() {\n                    var confidence = $('#confidence').val();\n                    $.post('/update_confidence', {confidence: confidence});\n                }\n                function updateClassification() {\n                    $.get('/get_classification', function(data) {\n                        $('#classification').text(data.label + ': ' \n                        + data.probability.toFixed(2));\n                    });\n                }\n                $(document).ready(function() {\n                    setInterval(updateClassification, 100);  \n                    // Update every 100ms\n                });\n            </script>\n        </head>\n        <body>\n            <h1>Image Classification</h1>\n            <img src=\"{{ url_for('video_feed') }}\" width=\"640\" height=\"480\" />\n            <br>\n            <button id=\"startBtn\" onclick=\"startClassification()\">\n            Start Classification</button>\n            <button id=\"stopBtn\" onclick=\"stopClassification()\" disabled>\n            Stop Classification</button>\n            <br>\n            <label for=\"confidence\">Confidence Threshold:</label>\n            <input type=\"number\" id=\"confidence\" name=\"confidence\" min=\"0\" \n            max=\"1\" step=\"0.1\" value=\"0.8\" onchange=\"updateConfidence()\">\n            <br>\n            <div id=\"classification\">Waiting for classification...</div>\n        </body>\n        </html>\n    ''')\n\n@app.route('/video_feed')\ndef video_feed():\n    return Response(generate_frames(),\n                    mimetype='multipart/x-mixed-replace; boundary=frame')\n\n@app.route('/start', methods=['POST'])\ndef start_classification():\n    global is_classifying\n    is_classifying = True\n    return '', 204\n\n@app.route('/stop', methods=['POST'])\ndef stop_classification():\n    global is_classifying\n    is_classifying = False\n    return '', 204\n\n@app.route('/update_confidence', methods=['POST'])\ndef update_confidence():\n    global confidence_threshold\n    confidence_threshold = float(request.form['confidence'])\n    return '', 204\n\n@app.route('/get_classification')\ndef get_classification():\n    if not is_classifying:\n        return jsonify({'label': 'Not classifying', 'probability': 0})\n    try:\n        result = classification_queue.get_nowait()\n    except Queue.Empty:\n        result = {'label': 'Processing', 'probability': 0}\n    return jsonify(result)\n\nif __name__ == '__main__':\n    initialize_camera()\n    threading.Thread(target=get_frame, daemon=True).start()\n    threading.Thread(target=classification_worker, daemon=True).start()\n    app.run(host='0.0.0.0', port=5000, threaded=True)\n\n```\n</div>\n\nOn the terminal, run:\n\n```bash\npython3 img_class_live_infer.py\n```\n\nAnd access the web interface:\n\n- On the Raspberry Pi itself (if you have a GUI): Open a web browser and go to `http://localhost:5000`\n- From another device on the same network: Open a web browser and go to `http://<raspberry_pi_ip>:5000` (Replace `<raspberry_pi_ip>` with your Raspberry Pi's IP address). For example: `http://192.168.4.210:5000/`\n\nHere are some screenshots of the app running on an external desktop\n\n![](images/png/app-inference.png)\n\nHere, you can see the app running on the YouTube:\n\n{{< video https://www.youtube.com/watch?v=o1QsQrpCMw4 >}}\n\nThe code creates a web application for real-time image classification using a Raspberry Pi, its camera module, and a TensorFlow Lite model. The application uses Flask to serve a web interface where is possible to view the camera feed and see live classification results.\n\n#### Key Components:\n\n1. **Flask Web Application**: Serves the user interface and handles requests.\n2. **PiCamera2**: Captures images from the Raspberry Pi camera module.\n3. **TensorFlow Lite**: Runs the image classification model.\n4. **Threading**: Manages concurrent operations for smooth performance.\n\n#### Main Features:\n\n- Live camera feed display\n- Real-time image classification\n- Adjustable confidence threshold\n- Start/Stop classification on demand\n\n#### Code Structure:\n\n1. **Imports and Setup**:\n    - Flask for web application\n    - PiCamera2 for camera control\n    - TensorFlow Lite for inference\n    - Threading and Queue for concurrent operations\n\n2. **Global Variables**:\n    - Camera and frame management\n    - Classification control\n    - Model and label information\n\n3. **Camera Functions**:\n    - `initialize_camera()`: Sets up the PiCamera2\n    - `get_frame()`: Continuously captures frames\n    - `generate_frames()`: Yields frames for the web feed\n\n4. **Model Functions**:\n    - `load_model()`: Loads the TFLite model\n    - `classify_image()`: Performs inference on a single image\n\n5. **Classification Worker**:\n    - Runs in a separate thread\n    - Continuously classifies frames when active\n    - Updates a queue with the latest results\n\n6. **Flask Routes**:\n    - `/`: Serves the main HTML page\n    - `/video_feed`: Streams the camera feed\n    - `/start` and `/stop`: Controls classification\n    - `/update_confidence`: Adjusts the confidence threshold\n    - `/get_classification`: Returns the latest classification result\n\n7. **HTML Template**:\n    - Displays camera feed and classification results\n    - Provides controls for starting/stopping and adjusting settings\n\n8. **Main Execution**:\n    - Initializes camera and starts necessary threads\n    - Runs the Flask application\n\n#### Key Concepts:\n\n1. **Concurrent Operations**: Using threads to handle camera capture and classification separately from the web server.\n2. **Real-time Updates**: Frequent updates to the classification results without page reloads.\n3. **Model Reuse**: Loading the TFLite model once and reusing it for efficiency.\n4. **Flexible Configuration**: Allowing users to adjust the confidence threshold on the fly.\n\n#### Usage:\n\n1. Ensure all dependencies are installed.\n2. Run the script on a Raspberry Pi with a camera module.\n3. Access the web interface from a browser using the Raspberry Pi's IP address.\n4. Start classification and adjust settings as needed.\n\n## Conclusion:\n\nImage classification has emerged as a powerful and versatile application of machine learning, with significant implications for various fields, from healthcare to environmental monitoring. This chapter has demonstrated how to implement a robust image classification system on edge devices like the Raspi-Zero and Raspi-5, showcasing the potential for real-time, on-device intelligence.\n\nWe've explored the entire pipeline of an image classification project, from data collection and model training using Edge Impulse Studio to deploying and running inferences on a Raspi. The process highlighted several key points:\n\n1. The importance of proper data collection and preprocessing for training effective models.\n2. The power of transfer learning, allowing us to leverage pre-trained models like MobileNet V2 for efficient training with limited data.\n3. The trade-offs between model accuracy and inference speed, especially crucial for edge devices.\n4. The implementation of real-time classification using a web-based interface, demonstrating practical applications.\n\nThe ability to run these models on edge devices like the Raspi opens up numerous possibilities for IoT applications, autonomous systems, and real-time monitoring solutions. It allows for reduced latency, improved privacy, and operation in environments with limited connectivity.\n\nAs we've seen, even with the computational constraints of edge devices, it's possible to achieve impressive results in terms of both accuracy and speed. The flexibility to adjust model parameters, such as input size and alpha values, allows for fine-tuning to meet specific project requirements.\n\nLooking forward, the field of edge AI and image classification continues to evolve rapidly. Advances in model compression techniques, hardware acceleration, and more efficient neural network architectures promise to further expand the capabilities of edge devices in computer vision tasks.\n\nThis project serves as a foundation for more complex computer vision applications and encourages further exploration into the exciting world of edge AI and IoT. Whether it's for industrial automation, smart home applications, or environmental monitoring, the skills and concepts covered here provide a solid starting point for a wide range of innovative projects.\n\n## Resources\n\n- [Dataset Example](https://github.com/Mjrovai/EdgeML-with-Raspberry-Pi/tree/main/IMG_CLASS/dataset)\n\n- [Setup Test Notebook on a Raspi](https://github.com/Mjrovai/EdgeML-with-Raspberry-Pi/blob/main/IMG_CLASS/notebooks/setup_test.ipynb)\n\n- [Image Classification Notebook on a Raspi](https://github.com/Mjrovai/EdgeML-with-Raspberry-Pi/blob/main/IMG_CLASS/notebooks/10_Image_Classification.ipynb)\n\n- [CNN to classify Cifar-10 dataset at CoLab](https://colab.research.google.com/github/Mjrovai/UNIFEI-IESTI01-TinyML-2022.1/blob/main/00_Curse_Folder/2_Applications_Deploy/Class_16/cifar_10/CNN_Cifar_10_TFLite.ipynb#scrollTo=iiVBUpuHXEtw)\n\n- [Cifar 10 - Image Classification on a Raspi](https://github.com/Mjrovai/EdgeML-with-Raspberry-Pi/blob/main/IMG_CLASS/notebooks/20_Cifar_10_Image_Classification.ipynb) \n\n- [Python Scripts](https://github.com/Mjrovai/EdgeML-with-Raspberry-Pi/tree/main/IMG_CLASS/python_scripts)\n\n- [Edge Impulse Project](https://studio.edgeimpulse.com/public/510251/live)\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":8,"fig-height":6,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["../../../../custom_callout.lua"],"reference-location":"margin","highlight-style":"github","toc":true,"toc-depth":4,"include-in-header":{"text":"<script async src=\"https://www.googletagmanager.com/gtag/js?id=G-M21L0CBCVN\"></script>\n<script type=\"module\"  src=\"/scripts/ai_menu/dist/bundle.js\" defer></script>\n"},"citeproc":true,"output-file":"image_classification.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author, Editor & Curator","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Last Updated","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.33","bibliography":["../../../../contents/core/introduction/introduction.bib","../../../../contents/core/ai_for_good/ai_for_good.bib","../../../../contents/core/benchmarking/benchmarking.bib","../../../../contents/core/data_engineering/data_engineering.bib","../../../../contents/core/dl_primer/dl_primer.bib","../../../../contents/core/efficient_ai/efficient_ai.bib","../../../../contents/core/ml_systems/ml_systems.bib","../../../../contents/core/frameworks/frameworks.bib","../../../../contents/core/generative_ai/generative_ai.bib","../../../../contents/core/hw_acceleration/hw_acceleration.bib","../../../../contents/core/ondevice_learning/ondevice_learning.bib","../../../../contents/core/ops/ops.bib","../../../../contents/core/optimizations/optimizations.bib","../../../../contents/core/privacy_security/privacy_security.bib","../../../../contents/core/responsible_ai/responsible_ai.bib","../../../../contents/core/robust_ai/robust_ai.bib","../../../../contents/core/sustainable_ai/sustainable_ai.bib","../../../../contents/core/training/training.bib","../../../../contents/core/workflow/workflow.bib","../../../../contents/core/conclusion/conclusion.bib"],"comments":{"giscus":{"repo":"harvard-edge/cs249r_book"}},"crossref":{"appendix-title":"Appendix","appendix-delim":":","custom":[{"kind":"float","reference-prefix":"Lab","key":"labq","latex-env":"lab"},{"kind":"float","reference-prefix":"Exercise","key":"exr","latex-env":"exr"},{"kind":"float","reference-prefix":"Video","key":"vid","latex-env":"vid"}]},"citation":true,"license":"CC-BY-NC-SA","editor":{"render-on-save":true},"resources":["../../../../CNAME"],"_quarto-vars":{"email":{"contact":"vj@eecs.harvard.edu","subject":["MLSys Book"],"info":"mailto:vj@eecs.harvard.edu?subject=\"CS249r%20MLSys%20with%20TinyML%20Book%20-%20\""},"title":{"long":"Machine Learning Systems","short":"Machine Learning Systems"}},"lightbox":true,"theme":{"light":["default","../../../../style.scss","../../../../style-light.scss"],"dark":["darkly","../../../../style.scss","../../../../style-dark.scss"]},"code-block-bg":true,"code-block-border-left":"#A51C30","table":{"classes":["table-striped","table-hover"]},"citation-location":"margin","sidenote":true,"linkcolor":"#A51C30","urlcolor":"#A51C30","anchor-sections":true,"smooth-scroll":false,"citations-hover":false,"footnotes-hover":false,"number-depth":3},"extensions":{"book":{"multiFile":true}}},"titlepage-pdf":{"identifier":{"display-name":"PDF","target-format":"titlepage-pdf","base-format":"pdf","extension-name":"titlepage"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":true,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":["../../../../_extensions/nmfs-opensci/titlepage/fonts/qualitype/opentype/QTDublinIrish.otf"],"shortcodes":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","filters":["C:\\Users\\kkleinbard\\Documents\\dev\\kai_projects\\tinyml\\tinyML_repo\\dev_10_26\\cs249r_book\\_extensions\\nmfs-opensci\\titlepage\\titlepage-theme.lua","C:\\Users\\kkleinbard\\Documents\\dev\\kai_projects\\tinyml\\tinyML_repo\\dev_10_26\\cs249r_book\\_extensions\\nmfs-opensci\\titlepage\\coverpage-theme.lua","../../../../custom_callout.lua"],"toc":true,"top-level-division":"chapter","number-sections":true,"toc-depth":3,"cite-method":"citeproc","reference-location":"margin","include-in-header":[{"file":"../../../../tex/header-includes.tex"}],"output-file":"image_classification.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"template-partials":["../../../../_extensions/nmfs-opensci/titlepage/_coverpage.tex","../../../../_extensions/nmfs-opensci/titlepage/_author-affiliation-themes.tex","../../../../_extensions/nmfs-opensci/titlepage/_header-footer-date-themes.tex","../../../../_extensions/nmfs-opensci/titlepage/_title-themes.tex","../../../../_extensions/nmfs-opensci/titlepage/_titlepage.tex","../../../../_extensions/nmfs-opensci/titlepage/before-body.tex","../../../../_extensions/nmfs-opensci/titlepage/pandoc.tex"],"revealjs-plugins":[],"bibliography":["../../../../contents/core/introduction/introduction.bib","../../../../contents/core/ai_for_good/ai_for_good.bib","../../../../contents/core/benchmarking/benchmarking.bib","../../../../contents/core/data_engineering/data_engineering.bib","../../../../contents/core/dl_primer/dl_primer.bib","../../../../contents/core/efficient_ai/efficient_ai.bib","../../../../contents/core/ml_systems/ml_systems.bib","../../../../contents/core/frameworks/frameworks.bib","../../../../contents/core/generative_ai/generative_ai.bib","../../../../contents/core/hw_acceleration/hw_acceleration.bib","../../../../contents/core/ondevice_learning/ondevice_learning.bib","../../../../contents/core/ops/ops.bib","../../../../contents/core/optimizations/optimizations.bib","../../../../contents/core/privacy_security/privacy_security.bib","../../../../contents/core/responsible_ai/responsible_ai.bib","../../../../contents/core/robust_ai/robust_ai.bib","../../../../contents/core/sustainable_ai/sustainable_ai.bib","../../../../contents/core/training/training.bib","../../../../contents/core/workflow/workflow.bib","../../../../contents/core/conclusion/conclusion.bib"],"comments":{"giscus":{"repo":"harvard-edge/cs249r_book"}},"crossref":{"appendix-title":"Appendix","appendix-delim":":","custom":[{"kind":"float","reference-prefix":"Lab","key":"labq","latex-env":"lab"},{"kind":"float","reference-prefix":"Exercise","key":"exr","latex-env":"exr"},{"kind":"float","reference-prefix":"Video","key":"vid","latex-env":"vid"}]},"citation":true,"license":"CC-BY-NC-SA","editor":{"render-on-save":true},"resources":["../../../../CNAME"],"_quarto-vars":{"email":{"contact":"vj@eecs.harvard.edu","subject":["MLSys Book"],"info":"mailto:vj@eecs.harvard.edu?subject=\"CS249r%20MLSys%20with%20TinyML%20Book%20-%20\""},"title":{"long":"Machine Learning Systems","short":"Machine Learning Systems"}},"documentclass":"scrbook","classoption":["abstract","titlepage"],"coverpage":true,"coverpage-title":"Machine Learning Systems","coverpage-bg-image":"../../../../cover-image-transparent.png","coverpage-author":["Vijay","Janapa Reddi"],"coverpage-theme":{"page-text-align":"center","bg-image-left":"0.225\\paperwidth","bg-image-bottom":7,"bg-image-rotate":0,"bg-image-opacity":1,"author-style":"plain","author-sep":"newline","author-fontsize":20,"author-align":"right","author-bottom":"0.15\\paperwidth","author-left":"7in","author-width":"6in","footer-style":"none","header-style":"none","date-style":"none","title-fontsize":57,"title-left":"0.075\\paperwidth","title-bottom":"0.375\\paperwidth","title-width":"0.9\\paperwidth"},"titlepage":true,"titlepage-theme":{"elements":["\\titleblock","Prof. Vijay Janapa Reddi","School of Engineering and Applied Sciences","Harvard University","\\vfill","With heartfelt gratitude to the community for their invaluable contributions and steadfast support.","\\vfill"],"page-align":"left","title-style":"plain","title-fontstyle":["huge","bfseries"],"title-space-after":"4\\baselineskip","title-subtitle-space-between":"0.05\\textheight","subtitle-fontstyle":["large","textit"],"author-style":"superscript-with-and","author-fontstyle":"large","affiliation-style":"numbered-list-with-correspondence","affiliation-fontstyle":"large","affiliation-space-after":"0pt","footer-style":"plain","footer-fontstyle":"large","logo-size":"0.15\\textheight","logo-space-after":"1\\baselineskip","vrule-width":"2pt","vrule-align":"left","vrule-color":"black"},"lof":false,"lot":false,"latex-engine":"xelatex","citation-package":"natbib","link-citations":true,"biblio-title":"References","title-block-style":"none","indent":"0px","fontsize":"10pt","citation-location":"block","fig-caption":true,"cap-location":"margin","fig-cap-location":"margin","tbl-cap-location":"margin","hyperrefoptions":["linktoc=all","pdfwindowui","pdfpagemode=FullScreen","pdfpagelayout=TwoPageRight"]},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","titlepage-pdf"]}